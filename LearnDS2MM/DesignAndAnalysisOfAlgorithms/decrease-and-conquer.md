## 减治法
减治技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。

包含关系引发的两种考虑方式：
* 自顶向下，递归考虑
* 从底至上，迭代实现

规模的变化方式：
* 减常量（decrease-by-a-constant） <br>
最常见的为减一变化。
* 减常因子（decrease-by-a-constant-factor） <br>
最常见的为二分变化。
* 减可变规模（variable-size-decrease） <br>
最常见为最大公约数计算 gcd(m,n) = gcd(n, m mod n)。

重要的问题类型
* 排序
* 查找
* 字符串处理
* 图问题
* 组合问题
* 几何问题
* 数值问题

<br>

##### 1. 插入排序
算法： InsertionSort
```
//输入： n 个可排序元素构成的一个数组 A[0…n-1]
//输出： 非降序排列的数组 A[0…n-1]
for i ← 1 to n-1 do
  v ← A[i]
  j ← i-1
  //移动已排序数组
  while j ≧ 0 and A[j] > v do
    A[j+i] ← A[j]
    j ← j-1
  //插入
  A[j+1] ← v
```

##### 2. 拓扑排序
对图的边引入了方向之后，一些对无向图来说没有意义或微不足道的问题，成为了新的问题。

问题描述： 考虑五门必修课的一个集合 {C1，C2，C3，C4，C5}。 C1 和 C2 没有任何先决条件，修完 C1 和 C2 才能修 C3，
修完 C3 才能修 C4，而修完 C3 和 C4 才能修 C5。

##### 2.1 DFS - DepthFirstSearch
```
执行一次 DFS 遍历，并记住顶点变成死端的顺序。将该顺序反过来就可得到拓扑排序的一个解。
```

##### 2.2 减治技术
```
不断地这样一件事，在余下的有向图中求出一个源（source）。它是一个没有输入边的顶点。
```

##### 2.3 拓扑排序的用途
* 有些时候，我们做一件事情时需要确定给定的先决条件的集合是不矛盾的。要做到这一点的便利方法就是去求该先决条件结构图的一个拓扑排序的解。
* 运筹学。CPM (Critical Path Method，关键路径)、PERT (Program Evaluation and Review Technique，程序评估和检查技术)。

##### 3. 生成排列
##### 3.1 基于移动元素的方法
移动元素的定义
```
在每个元素上方标记一个箭头，该箭头指向两个相邻元素的较小一方。
如果被指的相邻元素小于当前元素，则该元素是移动元素。
例如： 排列 3241 中，3 和 4 为移动元素，而 2 和 1 就不是。
```

算法： JohnsonTrotter
```
//输入： 一个正整数 n
//输出： {1,...,n} 的所有排列的列表
将第一个排列初始化为 12···n
while 存在一个移动元素 do
  求最大的移动元素 k
  把 k 和它箭头指向的相邻元素互换
  调转所有大于 k 的元素的方向
  将新排列添加到列表中
```

##### 3.2 生成满足字典序的排列
算法： LexicoGraphicPermute
```
//输入： 一个正整数 n
//输出： 在字典序下， {1,...,n} 所有排列的列表
将第一个排列初始化为 12···n
while 最后一个排列有两个连续升序的元素 do
  找出使得 A[i] < A[i+1] 的最大的 i  //A[i+1] > A[i+2] > ··· > A[n]
  找到使得 A[i] < A[j] 的最大索引 j  //j≧ i+1，因为 A[i] < A[i+1]
  swap A[i] and A[j]  //此时， A[i+1] A[i+2] ... A[n] 将仍保持降序
  将 A[i+1] 到 A[n] 的元素反序，然后把这个新排列添加到列表中。
```

##### 4. 生成子集
算法： 二进制反射格雷码（binary reflected Gray code, BRGC）
```
//输入： 一个正整数 n
//输出： 所有长度为 n 的格雷码位串列表
if n==1， 表 L 包含位串 0 和 位串 1
else 调用 BRGC(n-1) 生成长度为 n-1 的位串列表 L1
  把表 L1 倒序后复制给表 L2
  把 0 加到表 L1 中的每个位串前面
  把 1 加到表 L2 中的每个位串前面
  把表 L2 添加到表 L1 后面得到表 L
return L
```

##### 5. 折半查找
算法： BinarySearch
```
//输入： 一个升序数组 A[0..n-1] 和一个查找键 K
//输出： 一个数组元素的下标，该元素等于 K；如果没有这样一个元素，则返回 -1。
l ← 0； r ← n-1
while l ≦ r do 
  m ← floor（(l+r)/2）
  if K == A[m] return m
  else if K < A[m] r ← m-1
  else l ← m+1
return -1
```

##### 6. 假币问题
问题描述： 在 n 枚外观相同的硬币中，有一枚是假币，假币较真币的重量轻。

解决思路：
将硬币分为两堆，然后放于天平上。如果两堆硬币一样重，则多出的一个硬币为假币；否则，将较轻的一堆硬币依照之前方法一分为二继续处理。

**特别说明**：<br>
对于假币问题，有意思的地方在于，实际上二分法并不是最高效的解法。如果把硬币分成三堆，每堆 n/3 个硬币，将会更好。

##### 7. 俄式乘法
问题描述： 假设 n 和 m 是两个正整数，现在请计算它们的乘积。

解决思路：
* 如果 n 为偶数，n x m = n/2 x 2m。
* 如果 n 为奇数，n x m = (n-1)/2 x 2m + m。

##### 8. 约瑟夫斯问题
问题描述： n 个人围成一圈，并将他们从 1 到 n 编上号码，从 1 开始每个人轮流消去他旁边的人。

解决思路：
* 当 n 为偶数时，n = 2k；可得每个人新编号与旧编号的关系 J(2k) = 2J(k)-1。
* 当 n 为奇数时，n = 2k+1；可得每个人新编号与旧编号的关系 J(2k+1) = 2J(k)+1。

计算过程如下:
```
J(1) = 1
J(2) = 2J(1) - 1 = 1
J(3) = 2J(1) + 1 = 3
...
```

##### 9. 计算中值
##### 9.1 选择问题
求一个 n 个数列表的第 k 个最小元素的问题。

##### 9.2 顺序统计量（order statistic）
选择问题的返回结果，即被找到的元素，称为第 k 个顺序统计量。
* 当 k = 1 时，该顺序统计量又称为最小值。
* 当 k = n 时，该顺序统计量又称为最大值。
* 当 k = ceil(n/2) 时，该顺序统计量又称为中值。

##### 9.3 Lomuto 划分
算法： LomutoPartition
```
//输入： 数组 A[0..n-1] 的一个子数组 A[l..r]，它由左右两边的索引 l 和 r （l≦r） 定义。
//输出： A[l..r] 的划分和中轴的新位置。
p ← A[l]
s ← l
for i ← l+1 to r do
  if A[i] < p
    s ← s+1; swap(A[s],A[i])
swap(A[l],A[s])
return s
```
注意： Lomuto 划分的意义在于，不对数组进行排序的情况下进行二分法切分。

##### 9.4 快速选择
算法： QuickSelect
```
//输入： 可排序数组 A[0..n-1] 的子数组 A[l..r] 和整数 k。 (1 ≦ k ≦ r-l+1)
//输出： A[l..r] 中第 k 小元素的值。
s ← LomutoPartition（A[l..r]）
if s = l+k-1 return A[s]
else if s > l+k-1 QuickSelect(A[l..s-1],k)
else QuickSelect(A[s+1..r],l+k-1-s)
```
思路类似于假币问题的二分法查找思想，第一堆 or 第二堆？

##### 10. 插值查找
应用场景： 现有一个有序数组，查找其中的某个元素。

思路：我们假设数组 A\[0..n\] 是线性递增的，由此，基于要查找的值 v 和左右两端的元素 A\[l\], A\[r\] 之差，可计算出一个下标。
基于这个下标将数组一分为二，在左侧使用相同方法查找 or 在右侧使用相同方法查找。

##### 12. 二叉查找树
书中略去细节

##### 13. 拈游戏
拈游戏的特点：
* 所有游戏规则已知且公开。
* 同样的局面，每个玩家都有同样的可选走法。
* 两个玩家轮流走，其中一方最终获胜，不存在平局。
* 最后一位能够移动的玩家就是胜者。
