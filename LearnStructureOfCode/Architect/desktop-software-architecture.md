### Part II —— 桌面软件开发架构

#### 21. 桌面开发的宏观视角
从架构的角度，无论你在什么样的终端设备（比如：PC、手机、手表、手机等等），也无论你在做 Native 应用，还是基于 Web 和小程序，我们都可以统一称之为桌面程序。

一个桌面程序完整的架构体系如下，
<div align="center"><img src="pics/architecture-of-desktop-application.png" width="45%"></div>

###### 对于桌面程序，最核心的话题是交互。

从需求角度看，桌面程序的交互方式并不稳定，它的交互范式经历了很多次的迭代。

##### 21.1 命令行交互
—— 最早出现的交互范式

##### 特征
* 键盘 + 显示器。
* 输入被抽象为一段以回车（Enter 键）为结束的文本。
* （通常是单行文本，要输入多行文本，需要在行末输入“ \ ”对回车进行转义。）
* 命令行交互程序的输入输出可以被重定向。

##### 示意图
<div align="center"><img src="pics/paradigm-of-command-line-app.png" width="40%"></div>

##### 21.2 字符界面
* 键盘 + 显示器。
* 输入不再是一段文本，而是键盘按键事件（KeyDown 和 KeyUp）。
* 输出也不是一段文本，而是可以修改屏幕任何位置显示的字符。
* （此时，键盘的功用在需求上分化为两个：一是输入文本，二是输入命令。）
* 从输入文本的角度，需要有当前输入的光标（Caret）位置。

##### 示意图
<div align="center"><img src="pics/paradigm-of-character-ui-app.png" width="40%"></div>

上图的 TDI 含义是字符设备接口（Text Device Interface），它指的是一组向屏幕绘制文本的方法集合。 类似这样：
```go
func ClearScreen()
func DrawText(x, y int, text string)
```

##### 21.3 图形界面
—— 一个划时代的变化

##### 特征
* 键盘 + 鼠标 + 显示器 + 音箱。
* 与字符界面时期相比，图形界面时代变化的根源是输出的变化：从字符变成像素。
* 为什么会出现鼠标？ 因为屏幕精度太高，用键盘的方向键改变当前位置既笨拙又不方便。
* 为什么出现音箱？ 原因很平凡，只不过是声音设备演进的自然结果。以前是内置喇叭，现在是外置音箱。
* （与字符界面程序相比，图形界面程序还有一个重大变化：多窗口！！ 窗口（Window），也有人会把它叫视图（View）。）

###### 复杂的窗口会切分出多个逻辑独立的子窗口，以降低单个窗口的程序复杂性。

##### 示意图
<div align="center"><img src="pics/paradigm-of-graphical-ui-app.png" width="40%"></div>

上图的 GDI 含义是图形设备接口（Graphic Device Interface），它指的是一组向指定窗口(不是屏幕)绘制图形的方法集合。绘制的对象包括有几何图形、图像、文本等。

##### 注意
一旦界面涉及复杂的窗口系统，交互变得非常复杂。为了降低编程的负担，窗口系统往往接管了桌面程序的主逻辑，提供了一套基于事件驱动的编程框架，**业务代码由窗口系统提供的界面框架所驱动。**

##### 21.4 移动时代
鼠标交互方式被淘汰，变成了多点触摸。
###### “键盘 + 鼠标 + 显示器” ⇨ 触摸屏

##### 特征
* 触摸屏 + 麦克风 + 内置扬声器。
* 音箱被内置到手机中，变成内置扬声器。这些变化因移动设备便携性的述求引起。
* 从架构的角度，它们并没有引起实质性的变化，只是鼠标事件变成了触摸事件。

##### 智能交互
—— 麦克风让计算机多了一个输入：语音。

三种典型用法：
* 在应用内把语音录下来，直接作为类似照片视频的媒体消息，或者识别为文本去应用（比如语音搜索）。
* 作为语音输入法输入文本。（用法 1 的特例，因为输入法在操作系统中有特殊地位而单独列出。）
* 基于语音助手来交互。（类似 Siri）

##### 语音交互示意图
<div align="center"><img src="pics/paradigm-of-voice-ui-app.jpg" width="40%"></div>

###### 语音交互与图形界面，由于其复杂性，通常其业务代码都由交互系统提供的框架所驱动。

##### 21.5 总结
交互体验越来越自然，但从编程的角度来说，如果没有操作系统支持，实现难度也将越来越高。

同时也说明了一点： 桌面操作系统和服务端操作系统的演进方向非常不一样。 （桌面操作系统的演进方向主要是交互范式的迭代。）

#### 22. 图形界面程序的框架
—— 关注点聚焦于现在仍然占主流地位的图形界面程序。

###### 实现一个图形界面程序，最大的复杂性在于不同操作系统的使用接口完全不同，差异非常巨大。

好在，尽管操作系统的使用接口有异，但基本的大逻辑差不多。

##### 22.1 事件
无论是什么桌面操作系统，每个进程都有一个全局的事件队列（Event Queue）。

###### 当我们在键盘上按了一个键、移动或者点击鼠标、触摸屏幕等等，都会产生一个事件（Event），并由操作系统负责将它扔到进程的事件队列。

大体流程如下，
* 硬件产生了一个硬件中断；
* 操作系统的硬件中断处理程序收到对应事件；
* 确定事件的目标进程；
* 事件被放入目标进程的事件队列。

##### 22.2 窗口与事件响应
一个窗口响应发送给它的事件（Event），修改内部的状态，然后调用 GDI 绘制子系统更新界面显示。

##### 响应事件的常见机制有两种，
* 事件处理类(EventHandler 或叫 Responder)
* 委托(delegate)

（事件处理类）自定义的窗口类会直接或间接从事件处理类继承。 （委托）事件处理不是收到事件的人自己来做，而是把它委托给了别人。

##### 思考： onPaint 或 onDraw
为什么会有这样的事件？ 想象以下场景：两个窗口存在遮挡，当我们移动一个窗口，以前被遮挡的部分现在不再被遮挡。
操作系统并不会帮我们保存被遮挡的窗口内容，而是发送 onPaint 事件给对应的窗口让它重新绘制。

##### 22.3 事件分派 —— 事件是怎么从全局的事件队列（Event Queue）到窗口的?
这就是事件分派（Event Dispatch）过程，它通常由一个事件分派循环（Event Dispatch Loop）来完成。

Windows 平台，类似以下流程，
```go
func RunLoop() {
  for {
    msg, ok := winapi.GetMessage() // 从事件队列中取出一个消息
    if !ok {
      break
    }
    winapi.TranslateMessage(msg)
    winapi.DispatchMessage(msg)
  }
}
```

其中，TranslateMessage 函数可能会比较陌生，它负责的是将键盘按键事件（onKeyDown、onKeyUp）转化为字符事件（onChar）。 敲击到文本输入的转换。

对于嵌套窗口，交互变得更为复杂。此时，事件分派依赖的是**事件处理链（EventHandler Chain）**。
* 首先由焦点窗口响应，再逐层上升，直到最顶层的窗口。

##### 22.4 窗口内容绘制
在收到 onPaint 或 onDraw 消息时，就要绘制窗口内容了，此时需要操作系统的 GDI 子系统。

从大分类来说，首先需要确定绘制的内容是 2D or 3D，
* 对于 2D 内容，操作系统 GDI 子系统往往有较好的支持，但不同平台终究还是会有较大的差异。
* 对于 3D 内容来说，OpenGL 这样的跨平台方案占据了今天的主流市场，而 Vulkan 号称是 NextGL。

###### 对于 GDI 的优化，GDI 优化往往通过硬件加速来完成，真正的关键角色是在硬件厂商这里。

##### 22.5 通用控件
为了进一步简化开发过程，操作系统往往还提供了一些通用的界面元素，通常我们称之为控件 (Control)。

###### 不同操作系统提供的基础控件大同小异。不过一些处理细节上的差异往往会成为跨平台开发的坑。

##### 22.6 总结
图形界面程序的三大块内容：事件、窗口事件响应、窗口内容绘制。 这些机制都是由操作系统提供支持。

###### 我们身处在由操作系统约定的编程框架中，这是桌面编程的特点。
<div align="center"><img src="pics/different-ui-os-subsystem-of-desktop-software.jpg" width="45%"></div>

这还不是全部。要做一个跨平台的桌面应用程序并不容易，我们需要面对的平台太多，
* PC：Windows、MacOS、Linux 等；
* PC 浏览器：Chrome、Safri、Firefox 等；
* 手机 / 平板 / 手表：Android（不同手机厂商也会有细节差异）、iOS 等；
* 小程序：微信、支付宝、快应用等。

怎么安排不同平台的优先级？怎么规划未来版本的迭代计划？选择什么样的跨平台方案？这些问题在业务架构之外，极其考验架构师的决策能力。

#### 23. 桌面程序的架构建议
—— 站在应用架构的角度，聊聊如何设计一个桌面应用程序。

前面的桌面程序框架介绍，都是站在操作系统交互子系统的角度分析。

现在从软件设计模式角度来分析。

##### 23.1 从 MVC 说起
关于桌面程序，听得最多的莫过于 MVC 这个架构范式。 MVC 全称是 “模型 (Model) - 视图 (View) - 控制器 (Controller)”。
<div align="center"><img src="pics/paradigm-of-mvc-pattern.png" width="45%"></div>

* Model 是数据。
* View 是数据的显示结果，同时也接受用户的交互动作，也就是事件。
* **Controller 负责 Process（处理），以 “Model + 由 View 转发的事件” 作为 Input，处理的结果（Output）仍然是 Model，作用是更新 Model 的数据。**
* **注意： Model 的数据更新后，发送 DataChanged 事件，View 会在监听并收到 DataChanged 事件后，更新 View。**

##### 23.2 MVP
对 MVC 模式做些细微的调整，就会产生一些变种。

##### MVP 模式 （Model-View-Presenter）
* Model 的数据更新发出 DataChanged 事件后，由 Controller 负责监听并 Update View。
<div align="center"><img src="pics/paradigm-of-mvp-pattern.png" width="45%"></div>

##### 23.3 思考： 如何判断程序架构是否优良？哪种架构范式比较好？
架构优劣的评判标准。 比较知名且重要的一些基本原则如下：
* 最低耦合原则。 不同子系统（或模块）之间有最少的交互频率，最简洁且自然的接口。
* 单一职责原则。 不要让一个子系统（或模块）干多件事情，也不要让它不干事情。

##### 23.4 深入理解 Model 层的意义
Model 层是承载业务逻辑的 DOM，即 “文档对象模型（Document Object Mode）”。 **直白理解，DOM 是 “面向对象” 意义上的数据。它不只是有数据结构，也有访问接口。**

##### 对于 Model 层，有两种常见的架构误区
* 误区一： 让 Controller 层直接操作数据库，也就是拿数据库的读写接口作为 Model 层的接口。
* 误区二： 用所谓的 ORM 技术来实现 Model 层，让 Controller 直接操作 ORM。

###### Model 层的真正价值所在是： Model 层的使用接口最重要的是要自然体现业务的需求。

##### Why?
* 只有这样（直接自然体现业务的需求），Model 层的边界才是稳定的，才与你基于的技术无关。

(是用了 MySQL，还是用了 NoSQL？是直接裸写 SQL 语句，还是基于 ORM？这都没关系，未来喜欢了还可以改。)

* 从界面编程角度看，Model 层越厚越好。 （逻辑更多向 Model 层倾斜，那么 Controller 层就简洁很多。）

因为，Model 层是和操作系统的界面程序框架最为无关的部分，是最容易测试的部分，也同时是跨平台最容易的部分。

###### 如果用一句话来描述 Model 层的职责，那么应该是 “负责业务需求的内核逻辑” —— “DataCore”。

##### Model 层为何要发出 DataChanged 事件？
这是从 Model 层的独立性考虑。 Model 层作为架构的最底层，它不需要知道其他层的存在。有了 DataChanged 事件，上层就能够感知到 Model 层的变化，从而作出自己的反应。

###### 如果还记得之前反复强调的：稳定点与变化点。显然，DataChanged 事件就是 Model 层面对需求变化点的对策。

##### 23.5 深入理解 View 层的意义
View 层首要的责任，是负责界面呈现。

界面呈现的两个选择，
* 直接调用 GDI 接口自己画。
* 创建子 View 让别人画。

View 层的另一个责任是被自然带来的： 响应用户交互事件的入口。 这是操作系统的界面编程框架决定的。

理想情况下，View 应该把自己所有的事件都委托（delegate）出去，不要自己干。 但是....View 层有以下问题需要考虑：

* View 层不一定会负责生成所有用户看到的 View。

（例如：有的 View 是 Controller 在做某个逻辑的过程中临时生成的，那么这样的 View 就应该是 Controller 的一部分。）

* View 层可能需要非常友好的委托（delegate）机制的的支持。

（例如：一组界面元素的交互事件共同做委托。）

* 负责界面呈现，意味着 View 层和 Model 层的关系非常紧密。

（这可能会导致 Model 层要为 View 层提供一些专享的只读访问接口。需要确保这些访问接口不要扩散使用。）

* 负责界面呈现，看似只是根据数据绘制界面，似乎很简单，但实则不简单。

（例如：有时为了效率，需要做局部更新的优化。）

###### 在局部更新这个优化足够复杂时，我们往往不得不在 Model 和 View 之间，再额外引入一层 ViewModel 层来做这个事情。

ViewModel 层顾名思义，是为 View 的界面呈现而设计的 Model 层，它的数据组织更接近于 View 的表达。
<div align="center"><img src="pics/paradigm-of-model-view-viewmodel.png" width="45%"></div>

##### Model-View-ViewModel 的例子
一个极端但又很典型的例子是 Word。 它是数据流式的文档，但是，界面显示常以页面视图方式，内容是分页显示的。

这种情况下就需要有一个 ViewModel 层是按分页显示的结构来组织数据。 其中负责维持 Model 与 ViewModel 层的数据一致性的模块，我们叫排版引擎。

###### 从理解上来讲，更倾向于认为 ViewModel 是 View 层的一部分，只不过是 View 层太复杂而进行了再次拆分的结果。 而不是单独作为一个模式。

##### 23.6 深入理解 Controller 层的意义
Controller 层是负责用户交互的。 可以有很多个 Controller，分别负责不同的用户交互需...

Controller 层与 Model 和 View 的差异：
* Model 层是一个整体。虽然这一个层会有很多类，但是它们共同构成了一个完整的逻辑：DOM。
* View 层也是一个整体，它是 DOM 的界面呈现，是 DOM 的镜像。
* 负责用户交互的 Controller 层，是被正交分解的，彼此完全没有耦合关系。

一个 Controller 模块，可能包含一些属于自己的辅助 View，也会接受 View 层委托的一些事件，由事件驱动自己。

###### Controller 层最应该思考的问题是代码的内聚性。哪些代码是相关的，是应该放在一起的，需要一一理清。

如果设计恰当，Controller 之间应该是完全无关的。而且要干掉某一个交互特别容易，都不需要删除该 Controller 本身相关的代码，只需要把创建该 Controller 的一行代码注释掉就可以。

##### 23.7 Model - View - Controller 的层次
从分层角度，
* Model 层在最底层；
* View 层在中间，它持有 Model 层的 DOM 指针；
* Controller 层在最上方，它知道 Model 和 View 层，通过 DOM 接口操作 Model 层，但不操作 View 去改变数据，而是监听兴趣事件。

###### 如果 View 层提供了抽象得当的事件绑定接口，将发现，Controller 层大部分的逻辑都与操作系统提供的界面编程框架无关（除了可能的辅助View的需要），是跨平台的。

##### MVC 各个模块是如何串起来的？
应用程序（Application）。 在应用开始的时候，它就把 Model 层、View 层，我们感兴趣的若干 Controller 模块都创建好，建立了彼此的关联。

##### 23.8 桌面应用程序的第二大需求
—— 提供应用程序的二次开发接口（API，全称为 Application Programming Interface）。

###### 提供了 API 的应用程序，意味着它身处一个应用生态之中，可以与其他应用程序完美协作。

##### 通过哪一层提供 API 接口？
倾向于认为最佳的选择是在 ViewModel 层。

#### 24. Web 开发：浏览器、小程序与 PWA
—— 原生应用(Native App)之外

##### 24.1 浏览器
##### 从商业价值的角度看，浏览器带来了三个重大进步，
* **软件服务化。** 产品交付从单机软件转向云服务，同时，社会分工发生巨变，任何一个环节都可能成长出一个超级节点，进而吞噬上下游，让服务链条更短。
* **随时发布。** 人们快速试验自己的想法，不必过度因为顾虑软件质量召回而束手束脚。(服务端可以及时更新与处理，所谓的召回和传统意义已不同。)
* **跨平台。** 浏览器消除了不同操作系统平台的差异性。

##### 从界面开发的角度看，浏览器带来的重大变化，
* **操作系统的窗口系统被颠覆。** 一个网页只是一个窗口，不再有父子窗口。网页中的界面元素都是一个虚拟视图，常规的通用控件(input,image,div等)和自绘窗口(canvas)都一样。
* **窗口的绘制机制变了。** 之前是调用操作系统的 GDI 生成界面，现在换成了 HTML+CSS。
* **语言限制。** 浏览器长期以来只支持 JavaScript 一门语言。
* **B/S 架构。** 无论是 B/S 还是 C/S，本质上还是软件服务化。这对软件架构产生了巨大影响。 （从 server 端看，系统从单用户变成了多用户。从 browser/client 端看，仍然是单用户，但是没有了数据。）

从 MVC 角度分析 HTML+CSS，我们不能把它理解为 View 层，它其实是 ViewModel 层。 View 层由谁干掉了？浏览器。怎么做到局部更新优化的？你不必关心，浏览器已完成支持。
###### 这事的真正价值超过你的想象。它大幅提升了桌面应用开发的效率。

##### 24.2 小程序
小程序引发的思考
<div align="center"><img src="pics/thinking-caused-by-webapp.png" width="35%"></div>

##### 为什么微信小程序必然会成功？
因为，有 7 亿人同时使用的操作系统，很少。小程序变成了一支巨大的新兴力量，成为真正意义上的国产操作系统，对抗着 Android 和 iOS 两大移动操作系统生态。

##### 小程序生态仍然存在的诸多问题
* 最为关键的，是标准不统一。 虽然都叫小程序，但是它们的接口各自都在快速迭代，谈不上让开发者一次开发，到处可用。

##### 小程序和传统的 Web 开发有何不同？
其实有很大不同。小程序更像是 Native 程序在线化。 小程序是一个应用。
* 我们需要提交应用给微信或支付宝，它们掌控着 App 的生杀大权。
* 更牛的是，他们可以下线一个已经有千万甚至上亿级别用户的 App，让他们一无所有。

###### 这个风险如此之高，所有的厂商在拥抱微信的同时，必然时时刻刻想着如何逃离微信。

##### 思考： Facebook 扎克伯格的成功
```
在发布 Libra 的时候，他选择的是让一步，放弃 Control。
让一步，其实就是进一百步。
```

##### 24.3 PWA
—— 移动应用的在线化，Google 也同样在探索。

Google 的移动浏览器方案，叫 PWA，全称 “Progressive Web App”。

PWA 开始于 2015 年，比微信小程序早很多，并得到了苹果和微软的支持。从这个角度来说，PWA 的潜力不容小觑。

##### 怎么理解 PWA？
可以理解为海外版的小程序。

##### PWA 与小程序的差别在哪？
* 关注焦点不同。 PWA 更技术化，精力重心放在如何让 PWA 在断网情况下和本地应用有更一致的体验。小程序关注点在如何撬动这么庞大的用户市场。
* 演进思路不同。 PWA 基本上以兼容并对 Web 进行逐步改造升级为导向。
* PWA 并没有中心化的 AppStore，它更像是一项技术标准。

##### 怎么看待 PWA 的未来？
PWA 相比小程序来说太传统。 小程序符合现代操作系统的 “账号 (Account)- 支付 (Pay)- 应用市场 (AppStore)” 的商业闭环，但是 PWA 并没有账号，也没有支付。
