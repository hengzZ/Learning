### Part II —— 桌面软件开发架构

#### 21. 桌面开发的宏观视角
从架构的角度，无论你在什么样的终端设备（比如：PC、手机、手表、手机等等），也无论你在做 Native 应用，还是基于 Web 和小程序，我们都可以统一称之为桌面程序。

一个桌面程序完整的架构体系如下，
<div align="center"><img src="pics/architecture-of-desktop-application.png" width="45%"></div>

###### 对于桌面程序，最核心的话题是交互。

从需求角度看，桌面程序的交互方式并不稳定，它的交互范式经历了很多次的迭代。

##### 21.1 命令行交互
—— 最早出现的交互范式

##### 特征
* 键盘 + 显示器。
* 输入被抽象为一段以回车（Enter 键）为结束的文本。
* （通常是单行文本，要输入多行文本，需要在行末输入“ \ ”对回车进行转义。）
* 命令行交互程序的输入输出可以被重定向。

##### 示意图
<div align="center"><img src="pics/paradigm-of-command-line-app.png" width="40%"></div>

##### 21.2 字符界面
* 键盘 + 显示器。
* 输入不再是一段文本，而是键盘按键事件（KeyDown 和 KeyUp）。
* 输出也不是一段文本，而是可以修改屏幕任何位置显示的字符。
* （此时，键盘的功用在需求上分化为两个：一是输入文本，二是输入命令。）
* 从输入文本的角度，需要有当前输入的光标（Caret）位置。

##### 示意图
<div align="center"><img src="pics/paradigm-of-character-ui-app.png" width="40%"></div>

上图的 TDI 含义是字符设备接口（Text Device Interface），它指的是一组向屏幕绘制文本的方法集合。 类似这样：
```go
func ClearScreen()
func DrawText(x, y int, text string)
```

##### 21.3 图形界面
—— 一个划时代的变化

##### 特征
* 键盘 + 鼠标 + 显示器 + 音箱。
* 与字符界面时期相比，图形界面时代变化的根源是输出的变化：从字符变成像素。
* 为什么会出现鼠标？ 因为屏幕精度太高，用键盘的方向键改变当前位置既笨拙又不方便。
* 为什么出现音箱？ 原因很平凡，只不过是声音设备演进的自然结果。以前是内置喇叭，现在是外置音箱。
* （与字符界面程序相比，图形界面程序还有一个重大变化：多窗口！！ 窗口（Window），也有人会把它叫视图（View）。）

###### 复杂的窗口会切分出多个逻辑独立的子窗口，以降低单个窗口的程序复杂性。

##### 示意图
<div align="center"><img src="pics/paradigm-of-graphical-ui-app.png" width="40%"></div>

上图的 GDI 含义是图形设备接口（Graphic Device Interface），它指的是一组向指定窗口(不是屏幕)绘制图形的方法集合。绘制的对象包括有几何图形、图像、文本等。

##### 注意
一旦界面涉及复杂的窗口系统，交互变得非常复杂。为了降低编程的负担，窗口系统往往接管了桌面程序的主逻辑，提供了一套基于事件驱动的编程框架，**业务代码由窗口系统提供的界面框架所驱动。**

##### 21.4 移动时代
鼠标交互方式被淘汰，变成了多点触摸。
###### “键盘 + 鼠标 + 显示器” ⇨ 触摸屏

##### 特征
* 触摸屏 + 麦克风 + 内置扬声器。
* 音箱被内置到手机中，变成内置扬声器。这些变化因移动设备便携性的述求引起。
* 从架构的角度，它们并没有引起实质性的变化，只是鼠标事件变成了触摸事件。

##### 智能交互
—— 麦克风让计算机多了一个输入：语音。

三种典型用法：
* 在应用内把语音录下来，直接作为类似照片视频的媒体消息，或者识别为文本去应用（比如语音搜索）。
* 作为语音输入法输入文本。（用法 1 的特例，因为输入法在操作系统中有特殊地位而单独列出。）
* 基于语音助手来交互。（类似 Siri）

##### 语音交互示意图
<div align="center"><img src="pics/paradigm-of-voice-ui-app.jpg" width="40%"></div>

###### 语音交互与图形界面，由于其复杂性，通常其业务代码都由交互系统提供的框架所驱动。

##### 21.5 总结
交互体验越来越自然，但从编程的角度来说，如果没有操作系统支持，实现难度也将越来越高。

同时也说明了一点： 桌面操作系统和服务端操作系统的演进方向非常不一样。 （桌面操作系统的演进方向主要是交互范式的迭代。）

#### 22. 图形界面程序的框架
—— 关注点聚焦于现在仍然占主流地位的图形界面程序。

###### 实现一个图形界面程序，最大的复杂性在于不同操作系统的使用接口完全不同，差异非常巨大。

好在，尽管操作系统的使用接口有异，但基本的大逻辑差不多。

##### 22.1 事件
无论是什么桌面操作系统，每个进程都有一个全局的事件队列（Event Queue）。

###### 当我们在键盘上按了一个键、移动或者点击鼠标、触摸屏幕等等，都会产生一个事件（Event），并由操作系统负责将它扔到进程的事件队列。

大体流程如下，
* 硬件产生了一个硬件中断；
* 操作系统的硬件中断处理程序收到对应事件；
* 确定事件的目标进程；
* 事件被放入目标进程的事件队列。

##### 22.2 窗口与事件响应
一个窗口响应发送给它的事件（Event），修改内部的状态，然后调用 GDI 绘制子系统更新界面显示。

##### 响应事件的常见机制有两种，
* 事件处理类(EventHandler 或叫 Responder)
* 委托(delegate)

（事件处理类）自定义的窗口类会直接或间接从事件处理类继承。 （委托）事件处理不是收到事件的人自己来做，而是把它委托给了别人。

##### 思考： onPaint 或 onDraw
为什么会有这样的事件？ 想象以下场景：两个窗口存在遮挡，当我们移动一个窗口，以前被遮挡的部分现在不再被遮挡。
操作系统并不会帮我们保存被遮挡的窗口内容，而是发送 onPaint 事件给对应的窗口让它重新绘制。

##### 22.3 事件分派 —— 事件是怎么从全局的事件队列（Event Queue）到窗口的?
这就是事件分派（Event Dispatch）过程，它通常由一个事件分派循环（Event Dispatch Loop）来完成。

Windows 平台，类似以下流程，
```go
func RunLoop() {
  for {
    msg, ok := winapi.GetMessage() // 从事件队列中取出一个消息
    if !ok {
      break
    }
    winapi.TranslateMessage(msg)
    winapi.DispatchMessage(msg)
  }
}
```

其中，TranslateMessage 函数可能会比较陌生，它负责的是将键盘按键事件（onKeyDown、onKeyUp）转化为字符事件（onChar）。 敲击到文本输入的转换。

对于嵌套窗口，交互变得更为复杂。此时，事件分派依赖的是**事件处理链（EventHandler Chain）**。
* 首先由焦点窗口响应，再逐层上升，直到最顶层的窗口。

##### 22.4 窗口内容绘制
在收到 onPaint 或 onDraw 消息时，就要绘制窗口内容了，此时需要操作系统的 GDI 子系统。

从大分类来说，首先需要确定绘制的内容是 2D or 3D，
* 对于 2D 内容，操作系统 GDI 子系统往往有较好的支持，但不同平台终究还是会有较大的差异。
* 对于 3D 内容来说，OpenGL 这样的跨平台方案占据了今天的主流市场，而 Vulkan 号称是 NextGL。

###### 对于 GDI 的优化，GDI 优化往往通过硬件加速来完成，真正的关键角色是在硬件厂商这里。

##### 22.5 通用控件
为了进一步简化开发过程，操作系统往往还提供了一些通用的界面元素，通常我们称之为控件 (Control)。

###### 不同操作系统提供的基础控件大同小异。不过一些处理细节上的差异往往会成为跨平台开发的坑。

##### 22.6 总结
图形界面程序的三大块内容：事件、窗口事件响应、窗口内容绘制。 这些机制都是由操作系统提供支持。

###### 我们身处在由操作系统约定的编程框架中，这是桌面编程的特点。
<div align="center"><img src="pics/different-ui-os-subsystem-of-desktop-software.jpg" width="45%"></div>

这还不是全部。要做一个跨平台的桌面应用程序并不容易，我们需要面对的平台太多，
* PC：Windows、MacOS、Linux 等；
* PC 浏览器：Chrome、Safri、Firefox 等；
* 手机 / 平板 / 手表：Android（不同手机厂商也会有细节差异）、iOS 等；
* 小程序：微信、支付宝、快应用等。

怎么安排不同平台的优先级？怎么规划未来版本的迭代计划？选择什么样的跨平台方案？这些问题在业务架构之外，极其考验架构师的决策能力。
