#### 1. 怎样成长为优秀的软件架构师？
程序员的三个层次
* 搬砖师
* 工程师 <br>
  —— 致力于不断提升软件代码的工程质量的程序员。
* 架构师

代码质量的评判
* 可阅读性 （方便代码流转）
* 可扩展性 / 可维护性 （方便修改功能，添加新功能）
* 可测试性（质量管理）
* 可复用性（简化后续功能开发的难度）

###### 大部分商业软件都是一项极其复杂的工程，它们远比很多传统的建筑工程复杂得多，无论是涉及的人力、时间还是业务的变数都要多很多。

###### 光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。

##### 1.1 架构师团队
软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。

##### 1.2 架构师的责任
软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义。

从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。

##### 1.3 根基
核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。

#### 2. 架构设计的宏观视角

##### 2.1 操作系统
它首先要解决的是软件治理的问题。它要建立安全保护机制，确保你的电脑免受恶意软件侵害。同时，它也要建立软件之间的协作秩序，让大家按照期望的方式进行协作。

其次解决的是基础编程接口问题。 这些编程接口一方面简化了软件开发，另一方面提供了多软件共存（多任务）的环境，实现了软件治理。

##### 2.2 完整的程序架构是怎样的？
###### 服务端应用程序架构体系
<div align="center"><img src="pics/server-program-arc.png" width="40%"></div>

###### 客户端应用程序架构体系
<div align="center"><img src="pics/client-program-arc.png" width="40%"></div>

#### 3. 大厦基石：无生有，有生万物
—— 冯·诺依曼体系结构

##### 3.1 解剖架构的关键点是什么？
* 需求。
  1. 这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？
  1. 难点： “为什么?” 为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？
* 规格。
  1. 这个零部件接口是什么样的？它如何与其他零件连接在一起的？ (规格是零部件的连接需求的抽象。)
  1. 规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。

##### 3.2 为“解决一切的问题”而生
冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用“计算”来解决的问题。

“计算”的边界在哪里？ <br>
今天我们还没有人能够真正说得清。
<div align="center"><img src="pics/evolution-of-computing.jpg" width="55%"></div>

##### 3.3 冯·诺依曼体系的规格
冯·诺依曼引入了三类基础零部件：
* 中央处理器
* 存储
* 输入输出设备

##### 中央处理器
它负责程序（指令序列）的执行。指令序列在哪里？也存放在存储里面。计算机加电启动后，中央处理器从一个固定的存储地址开始执行。

##### 存储
存储可简单分为两类：
* 一类是内置支持的存储，通过常规的处理器指令可直接访问，比如寄存器、内存、计算机主板的 ROM。
* 一类是外置存储，它们属于输入输出设备。中央处理器本身并不能直接读写其中的数据。

冯·诺依曼体系中涉及的“存储”，指的是中央处理器内置支持的存储。

##### 输入输出设备
它是计算机开放性的体现，大大拓展了计算机的能力。每个设备通过一个端口与中央处理器连接。

通过这个端口地址，中央处理器可以和设备进行数据交换。数据交换涉及的数据格式由设备定义，中央处理器并不理解。

###### 和 “解决一切可以用‘计算’来解决的问题” 这个伟大的目标相比，冯·诺依曼体系的三类零部件的规格设计显得如此精简。

##### 3.4 需求是怎么被满足的？
* 需求的变化点在于，要解决的问题是五花八门包罗万象的。 如何以某种稳定但可扩展的架构来支持这样的变化？
* 需求的稳定之处在于，电脑的核心能力是固定的。 怎么表达电脑的核心能力？

电脑的核心能力是“计算”。 什么是计算？计算就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫“函数”。

next，
* 数据物理上在哪里？
* 一个具体的计算怎么表达？
* 如何和现实世界发生交互？

##### 输入输出设备从根本上解决的问题是什么？
是电脑无限可能的扩展能力。 最重要的一点，输入输出设备和电脑是完全异构的。输入输出设备对电脑来说就只是实现了某项能力的黑盒子。

##### 3.5 架构思维上我们学习到什么？
架构的第一步是需求分析。
* 从需求分析角度来说，关键要抓住需求的稳定点和变化点。
* 需求的稳定点，往往是系统的核心价值点。 (我)
* 需求的变化点，则往往需要相应去做开放性设计。 (供应商)

计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。

这样一来，“计算”需求的多样性只需要通过调整计算机主板上的 BIOS 程序，乃至外置存储中的操作系统启动程序就可以实现，而不必去修改中央处理器本身。 (接口的价值)

###### 当我们把所有的变化点从电脑的最核心部件中央处理器剥离后，中央处理器的需求变得极其稳定，可独立作为产品进行其核心价值的演进。 (生态)

#### 4. 汇编：编程语言的诞生
##### 4.1 编程的史前时代
人们只能通过理解 CPU 指令的二进制表示，将程序以二进制数据方式刻录到存储（比如 ROM 或硬盘）上。
这个时期的编程无疑是痛苦的，效率是极其低下的，仅仅将我们的想法表达出来就极其困难。

##### 4.2 与机器对话
汇编语言的出现，让写程序（编程）成为一个纯软件行为（出现“程序员”这个分工的标志）。

在表达能力上，汇编语言主要做了如下效率优化：
* 指令相关
    * 用文本符号（symbol）表达机器指令。
* 地址相关
    * 用文本符号（symbol）表达要操作的内存地址，并支持内存地址的自动分配。
    * 用文本符号（symbol）表达要调用的函数（function，也叫“过程 -procedure”）地址。
    * 用文本符号（symbol）表达要跳转的目标地址。

总结来说，汇编从指令能力上来说，和机器指令并无二致，它只不过把人们从物理硬件地址中解脱出来，以便专注于程序逻辑的表达。

汇编语言的出现要早于操作系统。操作系统的核心目标是软件治理，只有在计算机需要管理很多的任务时，才需要有操作系统。

#### 5. 编程语言的进化
编程语言在信息科技发展中的位置，如同人类文明中语言所在的位置。而编程语言写出来的软件（及其源代码），如同人类文明中不断被传承下来的图书典籍。

##### 5.1 软件是活的书籍
软件人类知识传承能力的一次伟大进化。
* 表达方式的多样性
  * 书籍只能通过文字描述来进行表达，这种表达方式依赖于人们对文字的理解，以及人的想象能力对场景进行还原。
  * 软件除了能够通过文字，还能够通过超链接、声音、动画、视频、实时的交互反馈等方式来还原场景。
* 对技术的现场还原
  * 书籍只能通过文字来描述技术，这可能导致技术的传承会出现偏差。
  * 软件对技术的还原可以是精确的，甚至软件本身可以是技术的一部分。 (除非技术本身适应不了潮流，退出了历史舞台。)

如果希望能够站在职业发展的至高点，你就需要理解和计算机沟通的语言，也就需要理解软件工程师们的语言。
无论你从事什么职业。

##### 如果你把编程语言升华为人类知识传承能力的进化，你就更能够清晰地预判到这样的未来：
###### 每一个小孩的基础教育中一定会有编程教育，就如同每一个小孩都需要学习物理和数学一样。

##### 5.2 编程范式的进化
编程语言从汇编开始，到今天还只有六十多年的历史，但是迭代之迅速，远超自然语言的迭代速度。

从思想表达的角度，有以下常见编程范式
* 过程式
* 函数式 <br>
  (如果你想用函数式编程，你需要重修数据结构这门课程，大学里面学的数据结构是不顶用了。)
* 面向对象 <br>
  面向对象主张尽可能把方法（其实就是过程）归纳到合适的对象（类）上，不主张全局函数（过程）。

##### 从 “面向对象” 到 “面向连接”
—— 面向对象的核心思想是引入**契约**，基于对象这样一个概念对代码的使用界面进行抽象和封装。

面向对象的优点：
* **清晰的使用界面。** 某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。
* **信息的封装。** 不主张绕过对象的使用接口侵入到对象的内部实现细节。
* **多态。** 通过接口，我们可以优雅地实现过程式编程中很费劲才能做到的一个能力：多态。

“继承”概念的褒贬不一 <br>
虽然继承带来了编码上的便捷性，但也带来了不必要的心智负担： 本来复合对象的唯一构造方法是组合，现在多了一个选择，继承。😊

不同编程范式并不是互斥的
* Java 是纯正的面向对象语言。
* C++ 明确主张说自己是多范式的。 (其实 C++ 的复杂性和多范式并没有什么关系)

##### 什么是面向连接的语言？
—— 所谓面向连接就是朴素的组合思想。

研究连接，就是研究人与人如何组合，研究代码与代码之间怎么组合。

面向对象创造性地把契约的重要性提高到了非常重要的高度，但这还远远不够。 并不是只有对象需要契约，语言设计的方方面面都需要契约。
* 代码规范约束了人的行为，是人与人的连接契约。
* 如果大家写代码的方式(实现方式)很不一样，语言就可能存在很多种方言，这对达成共识十分不利。 （消除实现方式引起的内部消耗，专注于意图的表达。）

###### 消除实现方式/方言引起的内部消耗，专注于意图的表达。 更低的沟通/连接内耗。

##### 5.3 其他方面的进化
从工程化能力的角度，工程化能力体现如下：
* 包（package），即代码的发布单元。
* 版本（version），即包的依赖管理。
* 文档生成（doc）。
* 单元测试（test）。

从语言的执行器的行为，语言划分为：
* 编译的目标文件为可执行程序。
* 生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码。
* 直接解释执行。

##### 5.4 语言对架构的影响是什么？
无论服务端，还是客户端，我们可以统一将其架构图简化为下图所示
<div align="center"><img src="pics/general-software-framework.png" width="40%"></div>

其中，
* 淡紫色是硬件层次的依赖，是程序工作的物理基础。
* 淡绿色的是软件层次的依赖，是程序工作的生态环境。
* 桔色的是库或源代码层次的依赖，是程序本身的组成部分。

##### 业务架构
从软件的业务架构来说，本身应该怎么拆分模块，每个模块具体做什么样的事情（业务边界是什么），这是业务需求本身决定的，和编程语言并没有关系。

但是，在描述每个模块的规格时，规格描述语言会面临如下两种选择：
* 选择某种语言无关的接口表示。
* 选择团队开发时采用的语言来描述接口。

本着 “如无必要勿增实体” 的原则，倾向于后者，用开发语言来做接口表示。

##### 其他影响
* 开发效率
* 后期维护

###### 要想有所突破，需要建立批判性思维。一种新思潮的兴起过程很容易用力过猛。 面向对象是一个很好的例子。面向对象是非常重要的进步，但是继承是一个过度设计。

#### 6. 如何实现可自我迭代的计算机？
当第一台以 “键盘+显示器” 为标准输入输出的现代计算机出现后，一个最小的功能集，但计算能力可自我迭代的计算机应该是什么样的？

从需求考虑，它应该有如下能力：
* 键盘和显示器的驱动程序
* 当时最主流的外置存储设备的驱动程序 （不一定是现代的硬盘）
* 汇编程序编辑器
* 汇编编译器
* 支持执行一段保存在外置存储设备中的机器代码程序！！ （现在的 BIOS 任务）

##### 6.1 需求陈列之后的需求分析
—— 优秀的架构师需要 “在心里对需求反复推敲”，同时对客户反馈的尊重。

###### 稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。

##### 变化点和稳定点
* 计算机分为三大类的零部件： 中央处理器、存储、输入输出设备。
* 中央处理器作为“计算”能力的核心，工作范畴清晰。
* 存储，一方面作为“计算”的输入输出，另一方面作为“计算”本身的承载（也就是程序），主要的变数在后者。
    * 计算机主板 ROM 上的启动程序（BIOS）
    * 外置存储上的软件
* 输入输出设备，除了键盘和显示器外，还有外置存储。 主要的变数在外置存储上。外置存储的数据格式设计成什么样？

##### BIOS 需要负责的事情
* 键盘和显示器的驱动程序
* 外置存储设备的驱动程序
* 支持执行外置存储中引导区的机器代码程序
* 跳转到外置存储的固定地址，把执行权交给该地址上的引导程序

引导程序拿到执行权后，我们不管它额外做了哪些事情，最终它要把执行权交给 sh 程序。

##### 需求的变化点
* 外置存储的数据格式。
* 用户最终拿到这个计算机后，会迭代出什么能力。 为此，设计了 sh 程序，让它支持在外置存储上执行任何应用程序。
* 编辑器的交互范式。 为此，设计了 vi 程序，让它迭代编辑器的能力。
* 汇编语言的使用范式。 为此，设计了 asm 程序，让它响应 CPU 指令集的迭代，以及汇编语言进化的迭代。

最终的架构如下
<div align="center"><img src="pics/mini-computer.png" width="40%"></div>

#### 7. 操作系统
在编程语言出现后，软件生产效率得到了大幅度的提升。随着越来越多软件的出现，自然而然就诞生了多个软件如何共处，也就是软件治理的需求。

几大需求
* 多任务需求
* 内存管理、文件系统的需求
* 设备管理的需求
* 进程间通讯、共享内存的需求
* 安全管理的需求 (病毒、恶意软件如何治理)

###### 如果没有一个中间的协调方，软件与软件之间并不知道彼此的存在。
—— 操作系统对于软件而言，它像一个大法官，制定规则并据此约束大家的行为。

##### 7.1 操作系统的启动过程
—— 操作系统是怎么获得执行权的？

计算机加电启动后，中央处理器（CPU）会从一个固定的存储地址加载指令序列执行。
通常，这个固定的存储地址指向计算机主板的 ROM 上的一段启动程序（BIOS）。

##### BIOS 包含的内容
* 存储设备的驱动程序，用以识别常规的外置存储设备。 (比如硬盘、光驱、U 盘)
* 基础外部设备的驱动程序。 (比如键盘、鼠标、显示器)
* 设备和启动配置的基础管理能力。
* 支持执行外置存储中引导区的机器代码程序。 (引导区代码执行)
* 跳转到外置存储引导区的固定地址，把执行权交给该地址上的引导程序。 (执行权转交)

注意，
* 引导区的引导程序有长度限制，因此只能做非常少的事情。
* 常规情况下，引导区程序只是简单地跳转到真正的操作系统的启动程序，如果是双系统，则进入系统选择菜单。

##### 7.2 操作系统的需求演进
早期，计算机还是单任务的，以计算为主，软件为操作硬件服务。提供计算机的“基础编程接口”，降低软件开发的负担，是操作系统更为原始的需求。

PC 时代，分别诞生了 UNIX 和 DOS 这两个影响深远的操作系统。

(微软 DOS 系统通过推动 PC 兼容机的发展，让操作系统不再依赖特定的硬件设备，也就因此脱离了 IBM 的臂膀，自己一飞冲天。—— 核心/稳定需求剥离的重要性)

此时，操作系统的需求要从 “客户价值” 和 “商业价值” 两个维度考虑。

##### 客户价值(围绕的核心能力)
* 进程管理、存储管理、输入设备管理、输出设备管理、网络管理、安全管理等。 (软件治理)
* 简化软件开发，提供运行环境。 (基础编程接口问题)

##### 商业价值(承载体)
* 操作系统成为基础的刚需软件，随着采购需求的急速增加而获利。
* **操作系统也是核心的流量入口。**

###### 为什么是 DOS/Windows 赢得了市场，这无关技术优劣，关键在于两者的商业路线差异。

##### 思考1：流量入口
```
为什么当年网景推 Netscape 浏览器的时候，微软很紧张？
浏览器是另一个软件治理的入口，本质上是操作系统之上的操作系统。
如果软件都运行在浏览器上，那么本地操作系统就沦为和硬件一般无二的管道了。
```
##### 思考2：流量变现的方式
```
苹果的 iOS 操作系统开启了新的玩法(收税模式)，它构建了新的商业闭环： 账号（Account）、支付（Pay）、应用市场（AppStore）。
* 帐号(互联网账号)是整个模式的前提，用于记录用户购买记录以及进行支付。
* 应用市场解决了两个问题：
    a. 应用的分发，解决了系统功能的无限扩展问题(客户价值)。
    b. 预装软件的软件个数总归有限的问题（商业价值）。
* 支付则是整个模式的承载体，无论是下载应用收费，还是应用内购买内容收费，都可以通过这个关卡去收税。
```
##### 思考3：现代操作系统的商业闭环
```
无论是本地操作系统 iOS 和 Android，还是 Web 操作系统（浏览器）如微信小程序，
都实现了 “帐号 - 支付 - 应用市场” 这样的商业闭环。
```

##### 7.3 操作系统的边界在哪里？
架构的第一步是需求分析。 架构也关乎用户需求，作为架构师我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。

要回答这个问题，需要看清楚三个角色的关系：
* 硬件（个人计算机、手机或其他）
* 操作系统
* 浏览器

早期，PC 兼容机的发展对 DOS/Windows 的发展有着至关重要的支撑意义。它让操作系统厂商有了独立的生存空间。

但是，移动时代，Google 收购 Android 后，通过免费策略占领移动操作系统的大半江山，一定程度上复制了微软的过程，但实际上并没有那么理想。
* Android 是免费的，Google 并没有从中收取软件 License 费用。
* 只能借助 Android 的市场占有率来推动 Google 的服务（例如搜索、Gmail 等等），通过 Google 服务来获取商业回报。
* iOS 操作系统引入的 “账号 - 支付 - 应用市场” 的收税模式，受益方是硬件（手机）厂商，而非操作系统厂商。 (所有手机厂商都不接受交出支付(Pay)这个核心系统给 Google)
* 一旦手机厂商长大立足 ，Google 服务也会被逐步替换。

Google 和 Android 手机厂商之间的联盟并不可靠，养肥的手机厂商会不断试探 Google 的底线，，而 Google 也会尝试去收紧政策，双方在博弈中达到平衡。

##### Google 博弈的原因
* 历史是不可复制的，人们对操作系统的重要性认知已经非常充分。
* 手机是个性化产品，硬件上并没有 PC 那么标准化。 个人计算机有兼容机，而手机并没有所谓的标准化硬件。

##### 操作系统与浏览器的博弈
起初，操作系统和浏览器看起来至少需求上是有差异化的：
* 操作系统，是以管理本地软件和内容为主（对内）。
* 浏览器，是以管理互联网内容为主（对外）。

但，这个边界必然会越来越模糊。
* 操作系统不涉足互联网内容？这是不可能的。 应用市场（AppStore）其实就是典型的互联网内容。
* 浏览器的生态里也有一些特殊的角色... 网址导航、搜索引擎、Web 应用市场...

那么，
* 操作系统、浏览器、（互联网）搜索引擎的关系是什么?
* 移动时代的浏览器会是什么样的；它和操作系统的关系又如何相处？

#### 8. 软件运行机制及内存管理
内存作为计算机最基础的硬件资源，有着非常特殊的位置。 CPU 可以直接访问的存储资源非常少，只有：寄存器、内存（RAM）、主板上的 ROM。

##### 寄存器
大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行。

##### 主板上的 ROM
非易失的只读存储。 ROM 非易失和只读的特点，决定了它非常适合存储计算机的启动程序（BIOS）。

##### 内存(RAM)
内存是唯一的 CPU 内置支持，且和程序员直接会打交道的基础资源。

##### 8.1 计算机运行全过程
从操作系统的视角来看，计算机的运行时序如下：
<div align="center"><img src="pics/computer-running-sequence.png" width="35%"></div>

在整个过程中，有多少个 “子计算过程(软件)”，它并不关心。

注意，
* BIOS 程序没有固化在 CPU 中，而是独立放到主板的 ROM 上，以应对计算机输入输出设备的变化。 (CPU 与输入输出设备解耦)
* 引导区引导程序，则是程序从内置存储（ROM）转到外置存储的边界。
* 引导区引导程序不固化在 BIOS 中，而是写在外置存储的引导区，是为了避免 BIOS 程序需要经常性修改。 (操作系统与输入输出设备解耦)
* BIOS - Basic Input Output System，其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。

OS(Operating System) 引导程序，则是外置存储(RAM)接手计算机控制权的真正开始。 这个过程发生了很多很多事情，最终操作系统会把执行权交给 OS Shell 程序。

##### 8.2 计算机是如何运行外置存储(RAM)上的软件的？
这和内存管理有关。 结合内存的作用，谈内存管理，需要谈清楚两个问题：
* 如何分配内存（给运行中的软件，避免它们发生资源争抢）
* 如何运行外置存储（比如硬盘）上的软件

##### 前提背景知识 —— CPU 的实模式和保护模式
两个模式下，CPU 对内存的操作方式完全不同:
* 实模式下，CPU 直接通过物理地址访问内存。
* 保护模式下，CPU 通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。

##### 实模式下的内存管理
在实模式操作系统下，所有软件包括操作系统本身，都在同一个物理地址空间下。在 CPU 看来，它们是同一个程序。

操作系统如何分配内存？ 至少有两种可行的方法。
* 其一，把内存管理相关的函数地址，放到一个大家公认的地方（比如 0x10000 处），每个软件要想申请内存就到这个地方取得内存管理函数并调用它。
* 其二，把内存管理功能设计为一个中断请求。 CPU 提供了指令允许软件触发一个中断，我们把它叫软中断。 比如我们约定 77 号中断为内存管理中断，在操作系统初始化时把自己的内存管理函数写到中断向量表的第 77 项。

##### 补充知识 —— 中断
所谓中断，是 CPU 响应硬件设备事件的一个机制。
```
当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断。
例如：
    内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放一堆函数地址。
比如键盘按了一个键，它会触发 9 号中断。 此时 CPU 会先停下手头的活，到中断向量表
找到第 9 项对应的函数地址并去执行它，完成后再回去干原来的活。
```

在实模式下，操作系统如何运行外置存储（比如硬盘）上的软件？
* 就是把软件完整从外置存储读入到内存然后执行它。
* 不过，在执行前它干了一件事情，把浮动地址固定下来。 为什么会有浮动地址？因为软件还没有加载到内存的时候，并不知道自己会在哪里。

实模式下的问题：
* 安全性。 操作系统以及所有软件都运行在一起，相互之间可以随意修改对方的数据甚至程序指令。
* 支持的软件复杂性低。 同时可运行的软件数量少。

##### 保护模式下的内存管理
保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。
* 虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如 64K。
* 当然，可能某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，没法读取数据，这时 CPU 就会发起一个缺页的中断请求。

发生缺页时，操作系统会为这个(逻辑)内存页分配物理的内存，并恢复这个内存页的数据。
如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。

<div align="center"><img src="pics/virtual-memory-system.png" width="45%"></div>

通过这个虚拟内存的机制，操作系统并不需要一上来就把整个软件装进内存中，而是通过缺页中断按需加载对应的程序代码片段。

操作系统如何分配内存给运行中的软件？
* 反正内存地址空间是虚拟的，操作系统可以一上来就给要运行的软件分配超级大的内存，软件如果不用某个内存页，什么都不发生。
* 每个运行中的软件，我们把它叫进程，都有自己的地址映射表。
* 也就是说，虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间。

在保护模式下，计算机的基础架构体系和操作系统共同在努力做的一件事情，就是让每个软件“感觉”自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点。
而在实模式下，所有进程都在同在物理内存的地址空间里。

##### 思考：进程注入
```
由保护模式的特性可知，进程注入是需要首先获得目标进程的虚拟地址空间，
通过访问虚拟地址空间从而实现的数据数据修改，其中涉及的缺页中断会帮助访问到实际的物理内存。
注意，进程的虚拟内存表是由操作系统维护的。 操作系统是把虚拟内存地址分页，引入缺页中断。
```

#### 9. 操作系统内核与编程接口
—— 软件如何利用它所依赖的基础架构

一个软件依赖的基础架构：
* 冯·诺依曼计算机体系
* 编程语言 (编程语言面向人类，CPU 指令面向机器)
* 系统调用

##### 9.1 系统调用
操作系统与冯·诺依曼计算机体系和编程语言非常不同。
* 软件都是某种编程语言写成的，而 CPU 和编程语言的能力，统一以语言的语法或者库体现。
* **操作系统则属于基础软件，它和我们编写的软件并不在同一个进程。**

由此，
* 实模式下的操作系统，大家都在同一个地址空间下，只需要知道操作系统的接口函数地址，理论上就可以直接访问。
* **操作系统和软件不在同一个进程，软件怎么才能使用操作系统的能力呢？**

它应该是一种成本非常非常低的方案，性能上要接近函数调用，否则我们为保护模式付出的成本就太高了。
它是所有软件进程使用操作系统能力的基础，包括进程与进程之间通讯的机制，也是建立在这个基础之上。

##### 中断
大部分情况下，操作系统的能力通过软中断向我们写的软件开放，为此还专门引入了一个术语叫 “系统调用（syscall）”。

##### 9.2 系统调用是怎么工作的？
在保护模式下，CPU 引入了 “保护环（Protection Rings）” 的概念。说白了，代码有执行权限等级的，如果权限不够，有一些 CPU 指令就不能执行。

##### 操作系统内核
其实就是指那些会向我们写的应用程序提供系统服务的子系统的集合，它们管理着计算机的所有硬件资源，也管理着所有运行中的应用软件（进程）。

* 操作系统内核的执行权限等级，和我们常规的软件进程不同。
* 由此，系统调用所基于的软中断，不只是“函数调用”，更重要的是改变了执行权限，从用户态跃迁到了内核态。
* 另外，操作系统与我们编写的软件并不同属一个进程(独立的内存地址空间)，我们系统调用请求是过去了，但是我们传给操作系统的内存地址，对它真的有意义吗？

答案，
* **从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间！！**
* 可以认为，操作系统内核，它是所有进程共享的内存。

<div align="center"><img src="pics/systemcall.png" width="45%"></div>

这非常有趣。 操作系统内核的代码和数据，不只为所有进程所共享，而且在所有进程中拥有相同的地址。 因此，
###### 无论哪个进程请求过来，对内核来说看起来都是一次本进程内的请求。

* 从单个进程的视角，中断向量表的地址，以及操作系统内核的地址空间是一个契约。
* 有了中断向量表的地址约定，用户态函数就可以发起一次系统调用（软中断）。

##### 思考： 既然操作系统内核和我同属一个地址空间，我是否可以跳过中断，直接访问调用内核函数？
答案是：不能。 这不单单是执行权限的问题。这涉及虚拟内存中的内存页保护机制。

操作系统内核虽然和用户进程同属一个地址空间，但是被设置为 “不可读、不可写、不可执行”。 虽然这段地址空间是有内容的，但是对于用户来说是个黑洞。

##### 9.3 编程接口
系统调用最原始的调用方式，是用软中断指令。在汇编语言里面通常是：
```
int < 中断号 > ; // 对每个操作系统来说中断号是固定的，比如 Linux 是 0x80
// 注意，此处的 int 不是 integer，而是 interrupt 的缩写。
```

当然用汇编语言来写软件并不是一个好主意。大部分高级语言都实现了操作系统编程接口的封装。

##### 操作系统（内核）有六大子系统
* 存储管理
* 输入设备管理
* 输出设备管理
* 进程管理
* 网络管理
* 安全管理

除了安全管理是一个“润物细无声”的能力外，其他子系统都会有所包装(API)。

##### 9.4 动态库
从操作系统的角度来说，它仅仅提供最原始的系统调用是不够的，有很多业务逻辑的封装，在用户态来做更合适。

同时，操作系统也无法去穷举所有的编程语言，去针对它们逐个开发基础库，因此，聪明的操作系统设计者们想了一个好办法：动态库。
* 动态库本质上是实现了一个语言无关的代码复用机制。 它是二进制级别的复用。

##### 动态库的原理其实很简单，核心考虑两个东西。
* 浮动地址。 动态库本质上是在一个进程地址空间中动态加载程序片段，这个程序片段的地址显然在编译阶段是没法确定的。
* 导出函数表。 动态库需要记录有哪些函数被导出（export），这样用户就可以通过函数的名字来取得对应的函数地址。

有了动态库，编程语言的设计者实现其标准库来说就多了一个选择： 直接调用动态库的函数并进行适度的语义包装，而不是直接用系统调用。 (实际上大家也是这么干的...)

##### 9.5 操作系统与编程语言
##### a. 先有编程语言，还是先有操作系统？
先有编程语言。
* 大部分人习惯认为运行软件是操作系统的责任。实际上软件跑起来是很容易的，关键看 BIOS 程序把控制权交给哪个软件。
* 实际上常见的系统级语言（比如 C 语言）都是可以编写出不依赖任何内核的程序的。

##### b. 编程语言怎么做到自举的？
编译器的进化史应该是这样的： 先用机器码直接写第一个汇编语言的编译器，然后汇编语言编译器编出第一个 C 语言编译器。
有了 C 语言编译器后，可以反过来用 C 语言重写汇编语言编译器和 C 语言编译器，做更多的功能增强。

##### c. 操作系统能够做到自身迭代本操作系统（自举）么？
当然可以。 通常一门新的操作系统开发之初，会用交叉编译技术先干出来，等到新操作系统稳定到一定程度后再实现自举。

交叉编译
```
所谓交叉编译就是在一种 “CPU + 操作系统” 架构下，生成另一种 “CPU + 操作系统” 架构下的软件。
```

#### 10. 外存管理与文件系统

##### 10.1 外存的分类
从经济效益上，新的存储设备会不断涌现，
* 更低的单位能耗（存储量 / 每日能源消耗成本）
* 更低的单位存储成本（存储量 / 可存储的时间 / 设备价格）
* 更高的访问性能。

从功能特性，
* 顺序读写型。 (磁带)
* 随机只读型。 (光盘)
* 随机读写型。 (盘、硬盘、U 盘、SSD 等)

适用场景划分
* 顺序读写型的外置存储（如磁带）我们日常并不常见，它的主要应用场景是归档，也就是数据备份。
* 随机只读型的外置存储（如光盘）我们日常有较多应用，常见的应用场景是资料分发和归档。
* 随机读写型的外置存储最为常见，存在于所有“能够称得上叫电脑”的设备上。

##### 10.2 外存的数据格式
外置存储和内存最大的区别是什么？
* 外置存储是持久存储，它的目的是用来存储资料的。
* 内存是临时存储，虽然是存储，但是它实质上是为 CPU 的计算服务的。

##### 外部存储的管理
直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。

因此，
* 我们希望这些写到外存中的数据是 “自描述” 的某种数据格式。
* 文件系统把存储设备中的数据组织成为了一棵树(目录树)。

尽管几乎所有文件系统的接口是非常一致的，但文件系统的实现却有很多。 不同外置存储的文件系统有不同的国际标准及多种底层实现。

例如，随机读写型的存储（如硬盘），常见的文件系统有如下这些：
* FAT32 —— 微软制定
* NTFS —— 微软制定
* HFS/HFS+ —— 苹果制定
* EXT3/EXT4 —— Linux 开源
* BTRFS —— 甲骨文(Oracle)
* JFS2 —— IBM 制定

从文件系统格式的设计角度来说，它和架构关联性不大，更多的是数据结构与算法的问题。

大部分现代文件系统都基于日志（journal）来改善文件系统的防灾难能力（比如突然断电，或不正常的 unmount 行为），基于 B 树(Balanced Tree)或 B+ 树组织元数据。

##### 外存分区
分区是一个非常简单而容易理解的行为，本质上只是把一个存储设备模拟成多个存储设备来使用而已。

##### 分区格式化
所谓格式化就是给这个分区生成文件系统的初始状态。格式化最重要的是标记分区的文件系统格式，并且生成文件系统的根目录。

##### 10.3 外存的使用接口
* 最简单的方式是用操作系统提供的命令行工具。
* 最原始的方式是 “系统调用”。 大部分编程语言对此都有相应的封装。

有意思的是，在早期，操作系统试图将所有的输入输出设备的接口都统一以 “文件” 来抽象它。 (例如：stdin 代表键盘，stdout 代表显示器。)
在 UNIX 系里面有个 “一切皆文件” 的口号，便由此而来。

但事实证明 UNIX 错了。 输入输出设备太多样化了，所谓的 “一切皆文件” 不过是象牙塔式的理想。
图形界面时代到来，编程接口产生颠覆性的变化。

##### 10.4 虚拟内存的支持
在物理内存不足的时候，操作系统会利用外存把一些很久没有使用的内存页的数据，保存到外存以进行淘汰。
* 在 UNIX 系的操作系统中，操作系统为此分配了一个磁盘分区叫 swap 分区。
* 在 Windows 操作系统中则通过一个具有隐藏属性的 .swp 文件来实现。

在缺页发生比较频繁时，内存页的数据经常性发生保存和恢复，这会发生大量的磁盘 IO 操作，非常占用 CPU 时间，能够非常明显感觉到计算机变得很慢。
###### 这也是将系统装在 SSD 上，明显感觉流畅的原因。 此时，增大物理内存或使用 SSD，最好两者同时。

如希望进一步研究某个文件系统的具体实现细节，推荐一个开源项目： BPL 语言（Binary Processing Language，二进制处理语言）。 <br>
https://github.com/qiniu/bpl

BPL 语言主要用于分析二进制数据格式。 应用场景包括：文件格式分析（含磁盘分区格式，因为一个磁盘分区可以把它理解为一个大文件）、网络协议分析。

#### 11. 输入和输出设备：交互的演进
人机交互在往越来越自然的方向发展。所谓自然，就是越来越接近于两个人直接的面对面沟通。

##### 11.1 输入设备
键盘、鼠标、麦克风、摄像头。

##### 键盘
键盘输入的管理机制和窗口系统的设计密切相关。为了让用户清楚键盘输入的目的地，窗口系统往往会有一个焦点窗口。

大部分情况下，键盘输入的事件会先发给焦点窗口，焦点窗口不处理则发给其父窗口，按此传递，直到有人处理了该按键事件，或者直到顶层窗口。

键盘从功能上来说，有两个不同的能力：
* 输入文本
* 触发命令

从触发命令的角度来说，命令的响应并不一定是在焦点窗口，甚至不一定在活跃窗口。 比如： Windows 下热键（HotKey）的概念。

##### 鼠标
鼠标输入的管理机制和键盘一样，和窗口系统的设计密切相关。但因为有位置，确定鼠标事件的目的地相比键盘事件要简单的多。

##### 麦克风
麦克风是一个非常有潜力的下一代输入设备。

语音交互今天仍然还很不成熟，究其原因，还停留在触发命令为主。 对于文本输入，其主要优势还在日常用语和长文本，在个性化场景如“输入人名之类”，较难达到好的结果。

###### 交互方式不管怎么变化，其核心需要实现的都是这样的两大能力： 输入文本和触发命令，这一点是不变的。

##### 摄像头
摄像头作为交互设备，引入了手势、表情。 从表达能力来说，这是最为丰富也是最为自然的一种表达方法。但是技术所限，只在萌芽阶段。

##### 11.2 输出设备
显示器（显卡）、音箱（声卡）、打印机。 输出设备的演化并不大，最主要的输出设备还是以显示器为主。

##### 显示器
显示器虽然经历了 CRT 到液晶屏多代更新，但也只是支持的色彩更多（从黑白到彩色到真彩色），分辨率越来越高。

除了窗口系统，显示设备管理的另一大挑战是绘制子系统，在操作系统中，有一个独立的子系统（通常叫 GDI）。 通常涉及以下概念：
* 2D 图形相关。 Path(路径)、Brush(画刷)、Pen(画笔) 等概念。
* 3D 图形相关。 Model(模型)、Material(材质)、Lighting(光照) 等概念。
* 文本相关。 Font(字体) 等概念。
* 图像处理相关。 Bitmap(位图) 对象及常见图像格式的编解码器 (Encoder/Decoder)。

##### 音箱
相比显示器的管理，音箱的设备管理要简单得多。

##### 打印机
打印机的管理方式又很不一样，软件使用打印机的过程基本上是互斥的。

软件操作打印机的时候，并不是等待打印机真把内容打印出来，而是把文档打印到打印缓冲中就完成打印。
