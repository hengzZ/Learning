#### 1. 怎样成长为优秀的软件架构师？
程序员的三个层次
* 搬砖师
* 工程师 <br>
  —— 致力于不断提升软件代码的工程质量的程序员。
* 架构师

代码质量的评判
* 可阅读性 （方便代码流转）
* 可扩展性 / 可维护性 （方便修改功能，添加新功能）
* 可测试性（质量管理）
* 可复用性（简化后续功能开发的难度）

###### 大部分商业软件都是一项极其复杂的工程，它们远比很多传统的建筑工程复杂得多，无论是涉及的人力、时间还是业务的变数都要多很多。

###### 光靠把控软件工程师的水平，依赖他们自觉保障的工程质量，是远远不够的。

##### 1.1 架构师团队
软件工程是一项非常复杂的系统工程，它需要依赖一个能够掌控整个工程全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。

##### 1.2 架构师的责任
软件架构师的职责，并不单单是我们通常理解的，对软件系统进行边界划分和模块规格的定义。

从根本目标来说，软件架构师要对软件工程的执行结果负责，这包括：按时按质进行软件的迭代和发布、敏捷地响应需求变更、防范软件质量风险（避免发生软件质量事故）、降低迭代维护成本。

##### 1.3 根基
核心在于对知识脉络的体系化梳理。这是架构能力构建和全面提升的关键。

#### 2. 架构设计的宏观视角

##### 2.1 操作系统
它首先要解决的是软件治理的问题。它要建立安全保护机制，确保你的电脑免受恶意软件侵害。同时，它也要建立软件之间的协作秩序，让大家按照期望的方式进行协作。

其次解决的是基础编程接口问题。 这些编程接口一方面简化了软件开发，另一方面提供了多软件共存（多任务）的环境，实现了软件治理。

##### 2.2 完整的程序架构是怎样的？
###### 服务端应用程序架构体系
<div align="center"><img src="pics/server-program-arc.png" width="40%"></div>

###### 客户端应用程序架构体系
<div align="center"><img src="pics/client-program-arc.png" width="40%"></div>

#### 3. 大厦基石：无生有，有生万物
—— 冯·诺依曼体系结构

##### 3.1 解剖架构的关键点是什么？
* 需求。
  1. 这个零部件的作用是什么？它能被用来做哪些事情？（某种意义上来说更重要的是）它不会被用来做哪些事情？
  1. 难点： “为什么?” 为何这个零件被设计成用来干这些事情的，而不是多干一点事情，或者为什么不是少干某些事情？
* 规格。
  1. 这个零部件接口是什么样的？它如何与其他零件连接在一起的？ (规格是零部件的连接需求的抽象。)
  1. 规格的约束条件会非常多样化，可能是外观（比如形状和颜色），可能是交互方式（比如用键盘、鼠标，或者语音和触摸屏），也可能是质量（比如硬度、耐热性等等）。

##### 3.2 为“解决一切的问题”而生
冯·诺依曼体系结构的迷人之处在于，从需求来说，它想解决一切问题。解决一切可以用“计算”来解决的问题。

“计算”的边界在哪里？ <br>
今天我们还没有人能够真正说得清。
<div align="center"><img src="pics/evolution-of-computing.jpg" width="55%"></div>

##### 3.3 冯·诺依曼体系的规格
冯·诺依曼引入了三类基础零部件：
* 中央处理器
* 存储
* 输入输出设备

##### 中央处理器
它负责程序（指令序列）的执行。指令序列在哪里？也存放在存储里面。计算机加电启动后，中央处理器从一个固定的存储地址开始执行。

##### 存储
存储可简单分为两类：
* 一类是内置支持的存储，通过常规的处理器指令可直接访问，比如寄存器、内存、计算机主板的 ROM。
* 一类是外置存储，它们属于输入输出设备。中央处理器本身并不能直接读写其中的数据。

冯·诺依曼体系中涉及的“存储”，指的是中央处理器内置支持的存储。

##### 输入输出设备
它是计算机开放性的体现，大大拓展了计算机的能力。每个设备通过一个端口与中央处理器连接。

通过这个端口地址，中央处理器可以和设备进行数据交换。数据交换涉及的数据格式由设备定义，中央处理器并不理解。

###### 和 “解决一切可以用‘计算’来解决的问题” 这个伟大的目标相比，冯·诺依曼体系的三类零部件的规格设计显得如此精简。

##### 3.4 需求是怎么被满足的？
* 需求的变化点在于，要解决的问题是五花八门包罗万象的。 如何以某种稳定但可扩展的架构来支持这样的变化？
* 需求的稳定之处在于，电脑的核心能力是固定的。 怎么表达电脑的核心能力？

电脑的核心能力是“计算”。 什么是计算？计算就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫“函数”。

next，
* 数据物理上在哪里？
* 一个具体的计算怎么表达？
* 如何和现实世界发生交互？

##### 输入输出设备从根本上解决的问题是什么？
是电脑无限可能的扩展能力。 最重要的一点，输入输出设备和电脑是完全异构的。输入输出设备对电脑来说就只是实现了某项能力的黑盒子。

##### 3.5 架构思维上我们学习到什么？
架构的第一步是需求分析。
* 从需求分析角度来说，关键要抓住需求的稳定点和变化点。
* 需求的稳定点，往往是系统的核心价值点。 (我)
* 需求的变化点，则往往需要相应去做开放性设计。 (供应商)

计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。

这样一来，“计算”需求的多样性只需要通过调整计算机主板上的 BIOS 程序，乃至外置存储中的操作系统启动程序就可以实现，而不必去修改中央处理器本身。 (接口的价值)

###### 当我们把所有的变化点从电脑的最核心部件中央处理器剥离后，中央处理器的需求变得极其稳定，可独立作为产品进行其核心价值的演进。 (生态)

#### 4. 汇编：编程语言的诞生
##### 4.1 编程的史前时代
人们只能通过理解 CPU 指令的二进制表示，将程序以二进制数据方式刻录到存储（比如 ROM 或硬盘）上。
这个时期的编程无疑是痛苦的，效率是极其低下的，仅仅将我们的想法表达出来就极其困难。

##### 4.2 与机器对话
汇编语言的出现，让写程序（编程）成为一个纯软件行为（出现“程序员”这个分工的标志）。

在表达能力上，汇编语言主要做了如下效率优化：
* 指令相关
    * 用文本符号（symbol）表达机器指令。
* 地址相关
    * 用文本符号（symbol）表达要操作的内存地址，并支持内存地址的自动分配。
    * 用文本符号（symbol）表达要调用的函数（function，也叫“过程 -procedure”）地址。
    * 用文本符号（symbol）表达要跳转的目标地址。

总结来说，汇编从指令能力上来说，和机器指令并无二致，它只不过把人们从物理硬件地址中解脱出来，以便专注于程序逻辑的表达。

汇编语言的出现要早于操作系统。操作系统的核心目标是软件治理，只有在计算机需要管理很多的任务时，才需要有操作系统。

#### 5. 编程语言的进化
编程语言在信息科技发展中的位置，如同人类文明中语言所在的位置。而编程语言写出来的软件（及其源代码），如同人类文明中不断被传承下来的图书典籍。

##### 5.1 软件是活的书籍
软件人类知识传承能力的一次伟大进化。
* 表达方式的多样性
  * 书籍只能通过文字描述来进行表达，这种表达方式依赖于人们对文字的理解，以及人的想象能力对场景进行还原。
  * 软件除了能够通过文字，还能够通过超链接、声音、动画、视频、实时的交互反馈等方式来还原场景。
* 对技术的现场还原
  * 书籍只能通过文字来描述技术，这可能导致技术的传承会出现偏差。
  * 软件对技术的还原可以是精确的，甚至软件本身可以是技术的一部分。 (除非技术本身适应不了潮流，退出了历史舞台。)

如果希望能够站在职业发展的至高点，你就需要理解和计算机沟通的语言，也就需要理解软件工程师们的语言。
无论你从事什么职业。

##### 如果你把编程语言升华为人类知识传承能力的进化，你就更能够清晰地预判到这样的未来：
###### 每一个小孩的基础教育中一定会有编程教育，就如同每一个小孩都需要学习物理和数学一样。

##### 5.2 编程范式的进化
编程语言从汇编开始，到今天还只有六十多年的历史，但是迭代之迅速，远超自然语言的迭代速度。

从思想表达的角度，有以下常见编程范式
* 过程式
* 函数式 <br>
  (如果你想用函数式编程，你需要重修数据结构这门课程，大学里面学的数据结构是不顶用了。)
* 面向对象 <br>
  面向对象主张尽可能把方法（其实就是过程）归纳到合适的对象（类）上，不主张全局函数（过程）。

##### 从 “面向对象” 到 “面向连接”
—— 面向对象的核心思想是引入**契约**，基于对象这样一个概念对代码的使用界面进行抽象和封装。

面向对象的优点：
* **清晰的使用界面。** 某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。
* **信息的封装。** 不主张绕过对象的使用接口侵入到对象的内部实现细节。
* **多态。** 通过接口，我们可以优雅地实现过程式编程中很费劲才能做到的一个能力：多态。

“继承”概念的褒贬不一 <br>
虽然继承带来了编码上的便捷性，但也带来了不必要的心智负担： 本来复合对象的唯一构造方法是组合，现在多了一个选择，继承。😊

不同编程范式并不是互斥的
* Java 是纯正的面向对象语言。
* C++ 明确主张说自己是多范式的。 (其实 C++ 的复杂性和多范式并没有什么关系)

##### 什么是面向连接的语言？
—— 所谓面向连接就是朴素的组合思想。

研究连接，就是研究人与人如何组合，研究代码与代码之间怎么组合。

面向对象创造性地把契约的重要性提高到了非常重要的高度，但这还远远不够。 并不是只有对象需要契约，语言设计的方方面面都需要契约。
* 代码规范约束了人的行为，是人与人的连接契约。
* 如果大家写代码的方式(实现方式)很不一样，语言就可能存在很多种方言，这对达成共识十分不利。 （消除实现方式引起的内部消耗，专注于意图的表达。）

###### 消除实现方式/方言引起的内部消耗，专注于意图的表达。 更低的沟通/连接内耗。

##### 5.3 其他方面的进化
从工程化能力的角度，工程化能力体现如下：
* 包（package），即代码的发布单元。
* 版本（version），即包的依赖管理。
* 文档生成（doc）。
* 单元测试（test）。

从语言的执行器的行为，语言划分为：
* 编译的目标文件为可执行程序。
* 生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码。
* 直接解释执行。

##### 5.4 语言对架构的影响是什么？
无论服务端，还是客户端，我们可以统一将其架构图简化为下图所示
<div align="center"><img src="pics/general-software-framework.png" width="40%"></div>

其中，
* 淡紫色是硬件层次的依赖，是程序工作的物理基础。
* 淡绿色的是软件层次的依赖，是程序工作的生态环境。
* 桔色的是库或源代码层次的依赖，是程序本身的组成部分。

##### 业务架构
从软件的业务架构来说，本身应该怎么拆分模块，每个模块具体做什么样的事情（业务边界是什么），这是业务需求本身决定的，和编程语言并没有关系。

但是，在描述每个模块的规格时，规格描述语言会面临如下两种选择：
* 选择某种语言无关的接口表示。
* 选择团队开发时采用的语言来描述接口。

本着 “如无必要勿增实体” 的原则，倾向于后者，用开发语言来做接口表示。

##### 其他影响
* 开发效率
* 后期维护

###### 要想有所突破，需要建立批判性思维。一种新思潮的兴起过程很容易用力过猛。 面向对象是一个很好的例子。面向对象是非常重要的进步，但是继承是一个过度设计。

#### 6. 如何实现可自我迭代的计算机？
当第一台以 “键盘+显示器” 为标准输入输出的现代计算机出现后，一个最小的功能集，但计算能力可自我迭代的计算机应该是什么样的？

从需求考虑，它应该有如下能力：
* 键盘和显示器的驱动程序
* 当时最主流的外置存储设备的驱动程序 （不一定是现代的硬盘）
* 汇编程序编辑器
* 汇编编译器
* 支持执行一段保存在外置存储设备中的机器代码程序！！ （现在的 BIOS 任务）

##### 6.1 需求陈列之后的需求分析
—— 优秀的架构师需要 “在心里对需求反复推敲”，同时对客户反馈的尊重。

###### 稳定点往往是系统的核心能力，而变化点则需要对应地去考虑扩展性上的设计。

##### 变化点和稳定点
* 计算机分为三大类的零部件： 中央处理器、存储、输入输出设备。
* 中央处理器作为“计算”能力的核心，工作范畴清晰。
* 存储，一方面作为“计算”的输入输出，另一方面作为“计算”本身的承载（也就是程序），主要的变数在后者。
    * 计算机主板 ROM 上的启动程序（BIOS）
    * 外置存储上的软件
* 输入输出设备，除了键盘和显示器外，还有外置存储。 主要的变数在外置存储上。外置存储的数据格式设计成什么样？

##### BIOS 需要负责的事情
* 键盘和显示器的驱动程序
* 外置存储设备的驱动程序
* 支持执行外置存储中引导区的机器代码程序
* 跳转到外置存储的固定地址，把执行权交给该地址上的引导程序

引导程序拿到执行权后，我们不管它额外做了哪些事情，最终它要把执行权交给 sh 程序。

##### 需求的变化点
* 外置存储的数据格式。
* 用户最终拿到这个计算机后，会迭代出什么能力。 为此，设计了 sh 程序，让它支持在外置存储上执行任何应用程序。
* 编辑器的交互范式。 为此，设计了 vi 程序，让它迭代编辑器的能力。
* 汇编语言的使用范式。 为此，设计了 asm 程序，让它响应 CPU 指令集的迭代，以及汇编语言进化的迭代。

最终的架构如下
<div align="center"><img src="pics/mini-computer.png" width="40%"></div>

#### 7. 操作系统
在编程语言出现后，软件生产效率得到了大幅度的提升。随着越来越多软件的出现，自然而然就诞生了多个软件如何共处，也就是软件治理的需求。

几大需求
* 多任务需求
* 内存管理、文件系统的需求
* 设备管理的需求
* 进程间通讯、共享内存的需求
* 安全管理的需求 (病毒、恶意软件如何治理)

###### 如果没有一个中间的协调方，软件与软件之间并不知道彼此的存在。
—— 操作系统对于软件而言，它像一个大法官，制定规则并据此约束大家的行为。

##### 7.1 操作系统的启动过程
—— 操作系统是怎么获得执行权的？

计算机加电启动后，中央处理器（CPU）会从一个固定的存储地址加载指令序列执行。
通常，这个固定的存储地址指向计算机主板的 ROM 上的一段启动程序（BIOS）。

##### BIOS 包含的内容
* 存储设备的驱动程序，用以识别常规的外置存储设备。 (比如硬盘、光驱、U 盘)
* 基础外部设备的驱动程序。 (比如键盘、鼠标、显示器)
* 设备和启动配置的基础管理能力。
* 支持执行外置存储中引导区的机器代码程序。 (引导区代码执行)
* 跳转到外置存储引导区的固定地址，把执行权交给该地址上的引导程序。 (执行权转交)

注意，
* 引导区的引导程序有长度限制，因此只能做非常少的事情。
* 常规情况下，引导区程序只是简单地跳转到真正的操作系统的启动程序，如果是双系统，则进入系统选择菜单。

##### 7.2 操作系统的需求演进
早期，计算机还是单任务的，以计算为主，软件为操作硬件服务。提供计算机的“基础编程接口”，降低软件开发的负担，是操作系统更为原始的需求。

PC 时代，分别诞生了 UNIX 和 DOS 这两个影响深远的操作系统。

(微软 DOS 系统通过推动 PC 兼容机的发展，让操作系统不再依赖特定的硬件设备，也就因此脱离了 IBM 的臂膀，自己一飞冲天。—— 核心/稳定需求剥离的重要性)

此时，操作系统的需求要从 “客户价值” 和 “商业价值” 两个维度考虑。

##### 客户价值(围绕的核心能力)
* 进程管理、存储管理、输入设备管理、输出设备管理、网络管理、安全管理等。 (软件治理)
* 简化软件开发，提供运行环境。 (基础编程接口问题)

##### 商业价值(承载体)
* 操作系统成为基础的刚需软件，随着采购需求的急速增加而获利。
* **操作系统也是核心的流量入口。**

###### 为什么是 DOS/Windows 赢得了市场，这无关技术优劣，关键在于两者的商业路线差异。

##### 思考1：流量入口
```
为什么当年网景推 Netscape 浏览器的时候，微软很紧张？
浏览器是另一个软件治理的入口，本质上是操作系统之上的操作系统。
如果软件都运行在浏览器上，那么本地操作系统就沦为和硬件一般无二的管道了。
```
##### 思考2：流量变现的方式
```
苹果的 iOS 操作系统开启了新的玩法(收税模式)，它构建了新的商业闭环： 账号（Account）、支付（Pay）、应用市场（AppStore）。
* 帐号(互联网账号)是整个模式的前提，用于记录用户购买记录以及进行支付。
* 应用市场解决了两个问题：
    a. 应用的分发，解决了系统功能的无限扩展问题(客户价值)。
    b. 预装软件的软件个数总归有限的问题（商业价值）。
* 支付则是整个模式的承载体，无论是下载应用收费，还是应用内购买内容收费，都可以通过这个关卡去收税。
```
##### 思考3：现代操作系统的商业闭环
```
无论是本地操作系统 iOS 和 Android，还是 Web 操作系统（浏览器）如微信小程序，
都实现了 “帐号 - 支付 - 应用市场” 这样的商业闭环。
```

##### 7.3 操作系统的边界在哪里？
架构的第一步是需求分析。 架构也关乎用户需求，作为架构师我们不只是要知道当前的用户需求是什么，我们还要预测需求未来可能的变化，预判什么会发生，而什么一定不会发生。

要回答这个问题，需要看清楚三个角色的关系：
* 硬件（个人计算机、手机或其他）
* 操作系统
* 浏览器

早期，PC 兼容机的发展对 DOS/Windows 的发展有着至关重要的支撑意义。它让操作系统厂商有了独立的生存空间。

但是，移动时代，Google 收购 Android 后，通过免费策略占领移动操作系统的大半江山，一定程度上复制了微软的过程，但实际上并没有那么理想。
* Android 是免费的，Google 并没有从中收取软件 License 费用。
* 只能借助 Android 的市场占有率来推动 Google 的服务（例如搜索、Gmail 等等），通过 Google 服务来获取商业回报。
* iOS 操作系统引入的 “账号 - 支付 - 应用市场” 的收税模式，受益方是硬件（手机）厂商，而非操作系统厂商。 (所有手机厂商都不接受交出支付(Pay)这个核心系统给 Google)
* 一旦手机厂商长大立足 ，Google 服务也会被逐步替换。

Google 和 Android 手机厂商之间的联盟并不可靠，养肥的手机厂商会不断试探 Google 的底线，，而 Google 也会尝试去收紧政策，双方在博弈中达到平衡。

##### Google 博弈的原因
* 历史是不可复制的，人们对操作系统的重要性认知已经非常充分。
* 手机是个性化产品，硬件上并没有 PC 那么标准化。 个人计算机有兼容机，而手机并没有所谓的标准化硬件。

##### 操作系统与浏览器的博弈
起初，操作系统和浏览器看起来至少需求上是有差异化的：
* 操作系统，是以管理本地软件和内容为主（对内）。
* 浏览器，是以管理互联网内容为主（对外）。

但，这个边界必然会越来越模糊。
* 操作系统不涉足互联网内容？这是不可能的。 应用市场（AppStore）其实就是典型的互联网内容。
* 浏览器的生态里也有一些特殊的角色... 网址导航、搜索引擎、Web 应用市场...

那么，
* 操作系统、浏览器、（互联网）搜索引擎的关系是什么?
* 移动时代的浏览器会是什么样的；它和操作系统的关系又如何相处？
