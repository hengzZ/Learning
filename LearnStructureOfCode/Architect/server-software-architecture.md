### Part III —— 服务端软件开发架构

#### 35. 服务端开发的宏观视角
服务端的诞生就是在 Internet 出现之后。服务端开发技术的迭代，一开始沿用了桌面操作系统的整套体系框架，现在，它正与桌面操作系统分道而行，转向数据中心操作系统（DCOS）之路。

##### 35.1 服务端程序的需求
—— 这些演进趋势的根源是什么？

* 规模。
* 连续服务时长。
* 质量要求。

从用户视角看，服务端程序 7x24 小时持续服务，任何时刻都不应该崩溃。就如同水电煤一样。

##### 35.2 服务端开发的体系架构
之前介绍的范式体系架构，是为了将桌面端与服务端统一。因此，仅仅是下图中虚线框内的部分。其实它只是服务端架构的一部分，是从服务端的单个实例看的。

一个服务端程序应该是一个多实例的分布式程序，其宏观体系架构如下：
<div align="center"><img src="pics/scheme-of-server-software-architecure.png" width="45%"></div>

相比桌面程序而言，服务端依赖的基础平台不只是操作系统和编程语言，多了两个重要的类：
* 负载均衡（Load Balance）；
* 数据库或其他形式的存储（DB/Storage）。

<br>

#### Part 3.1 —— 负载均衡 (***Load Balance***)

#### 36. 流量调度与负载均衡

##### 36.1 为什么会需要负载均衡（Load Balance）？ 什么是 “流量调度”？
首先，要了解以下概念
* 连接数
* IOPS
* 流量，入向流量和出向流量

###### 一个基本的服务端程序的服务请求，通常是由一个请求包（Request）和一个应答包（Response）构成。 这样一问一答就是一次完整的服务。

连接数 —— 又称 “并发数”，指的是同时在服务中的请求数。（指那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。）

IOPS —— 指的是平均每秒完成的请求（一问一答）的数量。 用来判断服务端程序的做事效率。

入向流量 —— 平均每秒收到的请求包（Request）数量 * 请求包平均大小。
出向流量 —— 平均每秒返回的应答包（Response）数量 * 应答包平均大小。
```
# 不考虑存在无效的请求包，也就是存在有问无答的情况的话。
● 入向流量 ≈ IOPS * 请求包平均大小
● 出向流量 ≈ IOPS * 应答包平均大小
```

所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。

##### 36.2 DNS 流量调度
* 什么是 DNS？ <br>
  Domain Name System，是域名解析系统，将域名映射为 IP 地址以便实现真正的网络访问。

* DNS 流量调度的精髓 <br>
  一个域名通过 DNS 解析到多个 IP，这样就实现了流量调度。

* DNS 流量调度的严重弊病 <br>
  1. 服务器升级不便。 要想升级 IP1 对应的服务端程序实例，必须先把 IP1 从 DNS 解析中去除。
  1. 流量调度不均衡。 域名解析均衡，并不代表真正的流量均衡。按域名解析做流量调度均衡，是非常粗糙的，实际结果并不可控。

##### 36.3 网络层（IP层）负载均衡
###### 案例： LVS (Linux Virtual Server，Linux虚拟服务器) —— 章文嵩
LVS 支持三种调度模式：
* VS/NAT： 通过网络地址转换（NAT）技术做调度。 请求和响应都会经过调度器中转，性能最差。
* VS/TUN： 把请求报文通过 IP 隧道转发至真实服务器，而真实服务器将响应直接返回给客户，调度器只处理请求报文。 这种做法性能比 VS/NAT 好很多。
* VS/DR： 通过改写请求报文的 MAC 地址，将请求发送到真实服务器，真实服务器将响应直接返回给客户。 相比 VS/TUN 少了 IP 隧道的开销，性能最好。

在网络层底层来做负载均衡，其特点是通用性强、性能优势高。但也有一些缺点。
```
思考： 假如某个业务服务器实例 RS 挂掉，但 LVS 调度器（Director Server）还没有感知到。。
## 在这个短周期内转发到该实例的请求都会失败。 这样的失败只能依赖客户端重试来解决。
```

##### 36.4 应用层负载均衡 （又称 “**应用网关**” “**反向代理**”）
—— 如何避免出现请求失败的情况？ 答案是：服务端重试。

###### Nginx 和 Apache 都是大家最为耳熟能详的 HTTP 应用网关。
HTTP 协议是应用最为广泛的应用层协议。 当前应用网关，绝大多数都是 HTTP 应用网关。

##### ● HTTP 网关的工作过程
HTTP 网关收到一个 HTTP 请求（Request）后，根据一定调度算法把请求转发给后端真实的业务服务器实例 RS（Real Server），收到 RS 的应答（Response）后，再把它转发给客户端。
（HTTP 反向代理）

##### ● HTTP 网关的重要优点 —— 服务端重试
重试非常好做。 在发现某个 RS 实例挂了后，HTTP 网关可以将同一个 HTTP 请求（Request）重新发给其他 RS 实例。

当然，为了能够支持重试，HTTP 请求（Request）需要被保存起来。

##### 36.5 优雅升级 （热更新）
有了负载均衡，不只是可以实现流量的均衡调度，连带业务服务器的升级也会方便很多。

###### 案例：前端是 HTTP 应用网关这种负载均衡的场景，升级的过程
* 升级系统通知升级的业务服务器（Real Server）实例退出。
* 要升级的 RS 实例进入退出状态，这时新请求进来直接拒绝（返回一个特殊的 Status Code），另外，等处理完所有处理中的请求后，RS 实例主动退出。
* 升级系统更新 RS 实例到新版本，并重启。

<br>

#### Part 3.2 —— 存储中间件

#### 37. 业务状态与存储中间件

##### 37.1 业务状态
思考： 桌面程序和服务端程序的相似之处在哪里，不同之处又在哪里？
* 一个桌面程序基本上是由一系列的 “用户交互事件” 所驱动。
* 一个服务端程序基本上是由 “网络 API 请求” 所驱动。

它们最大的差别是业务状态的表示不同。 桌面程序的业务状态是如何表示的？内存中的数据结构。

##### 37.2 存储中间件与容灾级别 —— 服务端程序的业务状态持久化

* 从历史上来看，第一个存储中间件是数据库，出现在 1974 年。

* 桌面程序很少用数据库。只有一些需要增量持久化业务状态的场景会被采用，比较典型的是微信。 采用的是嵌入式数据库，比如 **SQLite**。

对服务端开发来说，数据库的出现是革命性的，它大大提升了开发效率。

但在容灾级别这个事情上，随着互联网的普及，我们对它的要求越来越高。
* 首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。
* 其次，单机数据库是不够的，单机存储量终归有上限，这也是分布式数据库的来由。
* 最后，单机房的可靠性也是不够的，于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。

##### 37.3 “存储即数据结构” 的理念 —— 存储中间件
存储中间件是什么？存储中间件就是 “元数据结构”。

在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。

但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。 并且需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。

###### 由此，对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。
存储中间件会有多少？ 这与服务端开发的模型抽象有关。

###### “元数据结构”
```
其含义是，
数据结构的种类是非常有限的，并且最好理论可被证明，
有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。
```

##### 37.4 今天我们接触的存储中间件有哪些？
* 键值存储（KV-Storage）
* 对象存储（Object Storage）
* 数据库（Database）
* 消息队列（MQ）
* 倒排索引（SearchEngine）
* 等等

从目前看，存储中间件的种类是不可枚举的。 也许未来我们能够在这个问题上找到更加完美的答案。

#### 38. 键值存储与数据库

##### 38.1 数据库的种类
从使用界面（接口）的角度来说，
* 关系型数据库（Relational Database）
  ```
  以 MySQL、Oracle、SQLSever 为代表。
  # 特点：
    ● 每个条目（row）的数据分成多个项目（column）。
    ● 如果某个项目比较复杂，但从数据结构角度来说是一个结构体，就可以搞一个新的表（table）来存储它。
    ● 可以认为，主表只是存储一个 ID 来引用各个结构体（副表）。
  这类数据库的特点是强 schema，每个项目（column）有明确的数据类型。
  从业务状态的角度看，可以把一个表（table）理解为一个结构体。
  ```
* 文档型数据库（Document Database）
  ```
  以 MongoDB 为代表。
  # 特点：
    ● 每个条目（row）称为文档（document），每个文档用 JSON 或其他文档描述格式表示。
  文档型数据库大部分是无 schema 的，不对文档的数据格式的有效性进行检查。
  好处是，约束少，数据格式升级修改不受限。 坏处是，质量保障体系弱化，数据可能被弄脏而不自知。 “脏数据”
  ```
* 键值存储（KV Storage）
  ```
  以 Cassandra 为代表。
  # 特点：
    ● 键值存储明确只有唯一索引。
  MySQL 数据库是允许通过多个索引字段来检索的，
  因此，从使用角度来说，键值存储是数据库的特例。
  从底层实现技术角度，键值存储是数据库的基础。 每一组数据库的索引，往往背后就是一组键值存储。
  ```

##### 38.2 “事务” 的概念
无论是何种数据库，都面临一个重大选择：是否支持事务。

* 什么是事务？ <br>
  简单来说，事务就是把一系列数据库操作变成原子操作的能力。

* 事务的特性
    * 原子性（Atomicity）
    * 一致性（Consistency）
    * 隔离性（Isolation）
    * 持久性（Durability）

##### 乐观锁
先计算出所有修改的数据，然后最后一步统一提交修改。 提交时进行冲突检查。
###### 乐观锁让锁数据库的粒度降到最低。

##### 38.3 主从式结构
数据库必然考虑的三个问题
* 可用性（Availability），关注业务是否正常工作。
* 持久性（Durability），关注数据是否会被异常丢失。
* 一致性（Consistency），关注多个副本之间的数据更新一致。

##### 方案
解决这个问题的方法之一是采用主从（Master-Slave）结构。

主从结构采用的是一主多从模式，所有写操作都发往主（Master），所有从（Slave）都从主这边同步数据修改的操作。
###### 从（Slave）可以帮主（Master）分担一定的读压力。 但是不是所有的读操作都可以被分担。

##### 意义/核心
从（Slave）最重要的是和主（Master）形成了互备关系。在主挂掉的时候，某个从节点可以替代成为新的主节点。

##### 38.4 分布式结构
更加艰巨的问题
* 数据规模大到一定程度后，单个物理节点存放不了那么大的数据量。
* 主承受的读写压力太大，单台主节点承受不了这样高的 IOPS（吞吐能力）。

##### 方案
怎么解决？

分布式。 简单说，就是把数据分片存储到多台设备上的分片服务器一起构成一个单副本的数据库。 （“分片”）

分片的方式常见的有两种：
* 哈希分片（Hash based sharding）
* 范围分片（Range based sharding）

无论哪个分片方式，都会面临因为扩容缩容导致的重新分片过程。 重新分片意味着需要做数据的搬迁。

##### 意义/核心 —— 分片及 CAP 理论
在分布式存储领域，有一个著名（CAP）理论。
* 数据一致性 (Consistency)： 如果系统对一个写操作返回成功，那么之后的读请求都必须读到这个新数据，否则都不能读到新数据。
* 服务可用性 (Availability)： 所有读写请求在一定时间内必须得到响应，可终止、不会一直等待。
* 分区容错性 (Partition-tolerance)： 在网络分区的情况下，被分隔的节点仍能正常对外服务。
###### 分布式存储领域， C、A、P 三个目标不能兼得，我们同时只能取其二。

#### 39. 文件系统与对象存储

##### 39.1 异常处理才是存储的业务逻辑

存储为什么会复杂，需要从什么是存储谈起。
* 存储这个词非常平凡，“存储 + 计算” 构成了朴素的计算机模型，简单来说，存储就是负责维持计算系统的状态的单元。
* 从维持状态的角度，我们会有最朴素的可靠性要求。

###### 思考： 什么是最朴素的需求？
```
# 需求？ 需求之后的最朴素的夙愿 —— 可靠性。 所谓的 “靠谱”。
```

互联网时代，人们希望的服务是随时可获得并“靠谱”的。

##### 39.2 服务器程序怎么才能做到高可靠、高可用？
**答案是存储中间件。** 没有存储中间件，意味着所有的业务程序，都必须考虑每做一步就对状态进行持久化，以应对宕机等异常突发。

###### “业务逻辑上不宕机。”  “存储中间件” 的使用精髓 — 存储即数据结构！

对于大部分的业务程序（非存储系统相关）而言，你只需要重点关注业务的正常分支流程就行，对于出乎意料的情况，通常只需抛出一个错误，告诉用户你不该这么玩。

而存储系统解决的就是各种突发情况下的数据持久化和备份迁移，业务的正常分支就比较复杂难辨。

##### 39.3 从文件系统谈起
##### 多媒体文件（图片、音视频、Office 文档等）的保存
在服务端开发中，我们业务用到的多媒体，通常很少会去存储到数据库中，更多的是把它们放在文件系统里（服务器的磁盘上）。

文件系统的弊病：
* 伸缩性问题。 存储规模超过一台机器可管理的时候，应该怎么办。
* 性能瓶颈。 通常在文件数目达到临界点(一定数量)后，性能快速下降。
* 可靠性/持久性（Durability）。 单机文件系统通常只是单副本的方案，单副本已无法满足业务的持久性要求。
* 可用性要求。 单机文件系统通常只是单副本的方案，该机器出现问题将导致业务中断。

###### 数据需要有冗余（比较经典的做法是 3 副本），以便在磁盘损坏时及早修复丢失的数据，同时不影响业务。
```
在分布式存储系统出现前，有一些基于单机文件系统的改良版本被一些应用采纳。
比如：在单机文件系统上加 RAID5 做数据冗余。
 这种方案单机的可靠性大概是 100 年丢失一次数据。
但是，服务端存储只要规模够大，比如 10000 台，就会使得很多看起来是小概率的事件，变成必然事件。
```

##### 思考： 什么样的数据会有最大的存储规模？
答案是非结构化数据。 图片、音视频、Office 文档等多媒体文件，就是比较典型的非结构化数据。互联网上 90% 以上传输的数据量都是非结构化数据。

另外，这些数据不是以机器友好为目标，而是通常以用户体验友好为目标。 人们正在一步步把物理世界映射到数字世界。

##### 39.4 分布式存储
Google GFS 是很多人阅读的第一份分布式存储的论文，这篇论文奠定了 3 副本在分布式存储系统里的地位。随后 Hadoop 参考此论文实现了开源版的 GFS —— HDFS。

##### 39.5 对象存储
非结构化数据的存储方式，最理想的绝对不是分布式文件系统。

文件系统只是桌面操作系统为了方便用户手工管理数据而设计的产物。 对服务端体系架构来说，文件系统其实是一个过时的东西。

非结构化数据最佳的存储方式，还是键值存储（KV Storage）。 用于存储非结构化数据的 KV Storage，就叫 “对象存储”。
###### 对象存储的本质是 —— 键值存储。 但是，它和结构化数据的键值存储，实现机制上又有极大的差异。

``在对象存储中，并不存在目录（Directory）这样的概念。``
```
对象存储是一个键值存储，就意味着，可以通过对 Key 做 Hash，或者对 Key 按 Key Range 做分区，
从而，能够让请求快速定位到特定某一台存储机器上，转化为单机问题。
```

###### 补充话题： 为什么在数据库之后，会冒出来那么多 NoSQL 数据库。
```
数据库和文件系统一样，最早都是单机的，在伸缩性、性能瓶颈、可靠性、可用性上遇到了相同的麻烦。
# SQL 数据库，全称 关系型数据库。
  有关系意味着有多个索引，也就是有多个 Key，这对数据库转为分布式存储系统来说非常不利。
# NoSQL 数据库 —— KV Storage。
```

##### 39.6 “去关系/去目录” 和 一些其他考虑
文件系统的去关系，也就是去目录结构。 有目录意味着有父子关系。

针对对象存储及一些新兴的存储形式，放弃创建目录这样的想法是需要去适应的。
第一个大家公认的对象存储是 AWS S3，它最基本的访问接口如下：
```
func PutObject(bucket, key string, object io.Reader) (err error)
func GetObject(bucket, key string) (object io.ReadCloser, err error)
```

七牛云存储并不仅仅是简单的分布式存储，它需要额外考虑以下这些问题。
* 网络问题，也就是文件的上传下载问题。
    * 文件上传方面，需要考虑较差的网络条件下的文件上传和大文件的上传。
    * 文件下载方面，考虑到 CDN 已经发展了 10 多年的历史，决定基于 CDN 技术来做下载加速。
* 多媒体处理。
    * 图片缩略图相关的需求。
    * 音视频转码的需求。

``七牛云存储 = 对象存储 + 上传下载加速 + 多媒体处理``

##### 39.7 存储成本与持久性
存储作为一个服务被剥离出来，自然而然，最关心的就是单位存储成本问题。

通常我们用每 GB 每月花费多少钱来表示单位存储成本。

相应的，存储服务供应商也会考虑成本问题，其中最大的两个关联因素是
* 存储密度。 存储密度越高，单台机器的存储量越大，单位成本越低。
* 冗余度。 GFS 采用的是 3 副本冗余方案，实际上为了降低冗余度，通常采用的是纠删码（EC）这样的算术冗余方案。

#### 40. 存储与缓存



<br>

#### Part 3.3 —— 业务架构（系统设计/子系统划分）
大方向来说，业务架构必然是领域性的，与你所从事的行业息息相关。但是，如同桌面程序有 MVC 模式一样，服务端的业务架构也会有自己的套路。
