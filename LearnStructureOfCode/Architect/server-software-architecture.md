### Part III —— 服务端软件开发架构

#### 35. 服务端开发的宏观视角
服务端的诞生就是在 Internet 出现之后。服务端开发技术的迭代，一开始沿用了桌面操作系统的整套体系框架，现在，它正与桌面操作系统分道而行，转向数据中心操作系统（DCOS）之路。

##### 35.1 服务端程序的需求
—— 这些演进趋势的根源是什么？

* 规模。
* 连续服务时长。
* 质量要求。

从用户视角看，服务端程序 7x24 小时持续服务，任何时刻都不应该崩溃。就如同水电煤一样。

##### 35.2 服务端开发的体系架构
之前介绍的范式体系架构，是为了将桌面端与服务端统一。因此，仅仅是下图中虚线框内的部分。其实它只是服务端架构的一部分，是从服务端的单个实例看的。

一个服务端程序应该是一个多实例的分布式程序，其宏观体系架构如下：
<div align="center"><img src="pics/scheme-of-server-software-architecure.png" width="45%"></div>

相比桌面程序而言，服务端依赖的基础平台不只是操作系统和编程语言，多了两个重要的类：
* 负载均衡（Load Balance）；
* 数据库或其他形式的存储（DB/Storage）。

<br>

#### Part 3.1 —— 负载均衡 (***Load Balance***)

#### 36. 流量调度与负载均衡

##### 36.1 为什么会需要负载均衡（Load Balance）？ 什么是 “流量调度”？
首先，要了解以下概念
* 连接数
* IOPS
* 流量，入向流量和出向流量

###### 一个基本的服务端程序的服务请求，通常是由一个请求包（Request）和一个应答包（Response）构成。 这样一问一答就是一次完整的服务。

连接数 —— 又称 “并发数”，指的是同时在服务中的请求数。（指那些已经发送请求（Request），但是还没有收完应答（Response）的请求数量。）

IOPS —— 指的是平均每秒完成的请求（一问一答）的数量。 用来判断服务端程序的做事效率。

入向流量 —— 平均每秒收到的请求包（Request）数量 * 请求包平均大小。
出向流量 —— 平均每秒返回的应答包（Response）数量 * 应答包平均大小。
```
# 不考虑存在无效的请求包，也就是存在有问无答的情况的话。
● 入向流量 ≈ IOPS * 请求包平均大小
● 出向流量 ≈ IOPS * 应答包平均大小
```

所谓流量调度，就是把海量客户并发的请求包按特定策略分派到不同的服务端程序实例的过程。

##### 36.2 DNS 流量调度
* 什么是 DNS？ <br>
  Domain Name System，是域名解析系统，将域名映射为 IP 地址以便实现真正的网络访问。

* DNS 流量调度的精髓 <br>
  一个域名通过 DNS 解析到多个 IP，这样就实现了流量调度。

* DNS 流量调度的严重弊病 <br>
  1. 服务器升级不便。 要想升级 IP1 对应的服务端程序实例，必须先把 IP1 从 DNS 解析中去除。
  1. 流量调度不均衡。 域名解析均衡，并不代表真正的流量均衡。按域名解析做流量调度均衡，是非常粗糙的，实际结果并不可控。

##### 36.3 网络层（IP层）负载均衡
###### 案例： LVS (Linux Virtual Server，Linux虚拟服务器) —— 章文嵩
LVS 支持三种调度模式：
* VS/NAT： 通过网络地址转换（NAT）技术做调度。 请求和响应都会经过调度器中转，性能最差。
* VS/TUN： 把请求报文通过 IP 隧道转发至真实服务器，而真实服务器将响应直接返回给客户，调度器只处理请求报文。 这种做法性能比 VS/NAT 好很多。
* VS/DR： 通过改写请求报文的 MAC 地址，将请求发送到真实服务器，真实服务器将响应直接返回给客户。 相比 VS/TUN 少了 IP 隧道的开销，性能最好。

在网络层底层来做负载均衡，其特点是通用性强、性能优势高。但也有一些缺点。
```
思考： 假如某个业务服务器实例 RS 挂掉，但 LVS 调度器（Director Server）还没有感知到。。
## 在这个短周期内转发到该实例的请求都会失败。 这样的失败只能依赖客户端重试来解决。
```

##### 36.4 应用层负载均衡 （又称 “**应用网关**” “**反向代理**”）
—— 如何避免出现请求失败的情况？ 答案是：服务端重试。

###### Nginx 和 Apache 都是大家最为耳熟能详的 HTTP 应用网关。
HTTP 协议是应用最为广泛的应用层协议。 当前应用网关，绝大多数都是 HTTP 应用网关。

##### ● HTTP 网关的工作过程
HTTP 网关收到一个 HTTP 请求（Request）后，根据一定调度算法把请求转发给后端真实的业务服务器实例 RS（Real Server），收到 RS 的应答（Response）后，再把它转发给客户端。
（HTTP 反向代理）

##### ● HTTP 网关的重要优点 —— 服务端重试
重试非常好做。 在发现某个 RS 实例挂了后，HTTP 网关可以将同一个 HTTP 请求（Request）重新发给其他 RS 实例。

当然，为了能够支持重试，HTTP 请求（Request）需要被保存起来。

##### 36.5 优雅升级 （热更新）
有了负载均衡，不只是可以实现流量的均衡调度，连带业务服务器的升级也会方便很多。

###### 案例：前端是 HTTP 应用网关这种负载均衡的场景，升级的过程
* 升级系统通知升级的业务服务器（Real Server）实例退出。
* 要升级的 RS 实例进入退出状态，这时新请求进来直接拒绝（返回一个特殊的 Status Code），另外，等处理完所有处理中的请求后，RS 实例主动退出。
* 升级系统更新 RS 实例到新版本，并重启。

<br>

#### Part 3.2 —— 存储中间件

#### 37. 业务状态与存储中间件

##### 37.1 业务状态
思考： 桌面程序和服务端程序的相似之处在哪里，不同之处又在哪里？
* 一个桌面程序基本上是由一系列的 “用户交互事件” 所驱动。
* 一个服务端程序基本上是由 “网络 API 请求” 所驱动。

它们最大的差别是业务状态的表示不同。 桌面程序的业务状态是如何表示的？内存中的数据结构。

##### 37.2 存储中间件与容灾级别 —— 服务端程序的业务状态持久化

* 从历史上来看，第一个存储中间件是数据库，出现在 1974 年。

* 桌面程序很少用数据库。只有一些需要增量持久化业务状态的场景会被采用，比较典型的是微信。 采用的是嵌入式数据库，比如 **SQLite**。

对服务端开发来说，数据库的出现是革命性的，它大大提升了开发效率。

但在容灾级别这个事情上，随着互联网的普及，我们对它的要求越来越高。
* 首先，单机数据库是不够的，需要多机相互热备，这就是数据库主从结构的来由。
* 其次，单机数据库是不够的，单机存储量终归有上限，这也是分布式数据库的来由。
* 最后，单机房的可靠性也是不够的，于是就出现了“两地三中心”，跨机房容灾的数据灾备方案。

##### 37.3 “存储即数据结构” 的理念 —— 存储中间件
存储中间件是什么？存储中间件就是 “元数据结构”。

在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。

但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。 并且需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。

###### 由此，对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。
存储中间件会有多少？ 这与服务端开发的模型抽象有关。

###### “元数据结构”
```
其含义是，
数据结构的种类是非常有限的，并且最好理论可被证明，
有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。
```

##### 37.4 今天我们接触的存储中间件有哪些？
* 键值存储（KV-Storage）
* 对象存储（Object Storage）
* 数据库（Database）
* 消息队列（MQ）
* 倒排索引（SearchEngine）
* 等等

从目前看，存储中间件的种类是不可枚举的。 也许未来我们能够在这个问题上找到更加完美的答案。

#### 38. 键值存储与数据库






<br>

#### Part 3.3 —— 业务架构（系统设计/子系统划分）
大方向来说，业务架构必然是领域性的，与你所从事的行业息息相关。但是，如同桌面程序有 MVC 模式一样，服务端的业务架构也会有自己的套路。
